// -*- C++ -*-
//
// Package:	TTH/TTHNtupleAnalyzer
// Class:	  TTHNtupleAnalyzer
//
/**\class TTHNtupleAnalyzer TTHNtupleAnalyzer.cc TTH/TTHNtupleAnalyzer/plugins/TTHNtupleAnalyzer.cc

 Description: A simple N-tuplizer for TTH(->bb), mapping the EDM miniAOD format to a "simple flat ROOT TTree"

 Implementation:
	Based on https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
	The base event is described by TTHTree, implemented in tth_tree.hh (autogenerated by tree_header.jl based on a specification)

	Tests for this module are in test/runtests.sh

	Helpful links:
		https://github.com/CJLST/ZZAnalysis/wiki/miniAOD-twiki
		https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
*/
//
// Original Author:  Joosep Pata
//		 Created:  Tue, 15 Jul 2014 10:06:28 GMT
//
//


// system include files
#include <memory>
#include <algorithm>
#include <vector>
#include <string>
#include <iterator>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/Common/interface/ValueMap.h"
#include "DataFormats/BTauReco/interface/JetTag.h"

#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/JetReco/interface/Jet.h"
#include "DataFormats/JetReco/interface/GenJet.h"

#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"

#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/PackedCandidate.h"

//for top taggers
#include "DataFormats/BTauReco/interface/CATopJetTagInfo.h"
#include "DataFormats/JetReco/interface/HTTTopJetTagInfo.h"

#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"
#include "SimDataFormats/GeneratorProducts/interface/LHEEventProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/GenEventInfoProduct.h"
#include "SimDataFormats/JetMatching/interface/JetFlavourInfo.h"
#include "SimDataFormats/JetMatching/interface/JetFlavourInfoMatching.h"

#include <EgammaAnalysis/ElectronTools/interface/ElectronEffectiveArea.h>

#include "FWCore/Framework/interface/ESHandle.h"
#include "JetMETCorrections/JetCorrector/interface/JetCorrector.h"
#include "CondFormats/JetMETObjects/interface/JetCorrectorParameters.h"
#include "JetMETCorrections/Objects/interface/JetCorrectionsRecord.h"
#include "CondFormats/JetMETObjects/interface/JetCorrectionUncertainty.h"


#include "TTH/TTHNtupleAnalyzer/interface/tth_tree.hh"
#include "TTH/TTHNtupleAnalyzer/interface/gen_association.h"

#include "TStopwatch.h"

#include "TLorentzVector.h"
#include "TString.h"

#include <Math/VectorUtil.h>

#include "TTH/TTHNtupleAnalyzer/interface/helpers.h"

//TTH, EventHypothesis
#include "TTH/TTHNtupleAnalyzer/interface/EventHypothesis.hh"

//converts a vector of objects to a vector of pointers 
template <typename T, typename R>
std::vector<R> to_ptrvec(T coll) {
	std::vector<R> ret;
	for (auto e : coll) {
		assert(&e != NULL);
		ret.push_back((R)&e);
	}
	return ret;
}

//ordering function for pt sorting
template <typename T>
bool order_by_pt(T a, T b) {
	assert(a!=NULL && b!=NULL);
	return (a->pt() > b->pt());
};


// Return a pointer interface for all objects (reference or pointer)
// From:
// http://stackoverflow.com/questions/14466620/c-template-specialization-calling-methods-on-types-that-could-be-pointers-or/14466705
template<typename T>
T * ptr(T & obj) { return &obj; } //turn reference into pointer!
template<typename T>
T * ptr(T * obj) { return obj; } //obj is already pointer, return it!


// Functor so we can sort a list of ElementType objects according to
// their deltaR distance to the reference object.  
// Can take anything that inherits the p4() to give Lorentz Vector. 
// Can deal with references and pointers.
template <typename ReferenceType, typename ElementType>
struct distance_sorter
{  
  ReferenceType reference;
  distance_sorter(ReferenceType reference) : reference(reference) { }
  bool operator()(ElementType first, 
		  ElementType second){    
    return ROOT::Math::VectorUtil::DeltaR( ptr(first)->p4(), ptr(reference)->p4()) < ROOT::Math::VectorUtil::DeltaR( ptr(second)->p4(), ptr(reference)->p4());
  }
};


// Functor so we can sort a list of ElementType objects according to
// their deltaR distance to the reference object.  
// Can take anything that inherits the p4() to give Lorentz Vector as ElementType. 
// The reference already has to be a LorentzVector
// Can deal with references and pointers.
template <typename ElementType>
struct distance_sorter_p4
{  
   math::XYZTLorentzVector reference;
  distance_sorter_p4( math::XYZTLorentzVector reference) : reference(reference) { }
  bool operator()(ElementType first, 
		  ElementType second){    
    return ROOT::Math::VectorUtil::DeltaR( ptr(first)->p4(), reference) < ROOT::Math::VectorUtil::DeltaR( ptr(second)->p4(), reference);
  }
};


template <typename JetType>
void fill_truth_matching(TTHTree* tthtree, 				 
			 JetType x, // object for which to fill - fatjet or HTT cand
			 int n, // position at which to insert new values in the tree (ie n_fat_jet)
			 const vector<const reco::Candidate*>  & truth_particles, // particles for matching
			 std::string prefix, // prefix for branch names
			 std::string truth_name // what are we matching (to select branch name to fill into) hadtop/parton/..
			 ){

  // Branch names to fill
  std::string name_pt_branch = prefix + "close_";
  name_pt_branch += truth_name;
  name_pt_branch += "_pt";

  std::string name_dr_branch = prefix + "close_";
  name_dr_branch += truth_name;
  name_dr_branch += "_dr";

  std::string name_i_branch = prefix + "close_";
  name_i_branch += truth_name;
  name_i_branch += "_i";

  // Calculate the DeltaR from each truth particle to the jet
  std::vector<double> distances;
  for (vector<const reco::Candidate*>::const_iterator it = truth_particles.begin();
       it != truth_particles.end();
       ++it){
    distances.push_back(ROOT::Math::VectorUtil::DeltaR(ptr(*it)->p4(), ptr(x)->p4()));
  }   
  
  // And find the index of the closest one
 std::vector<double>::iterator min_distance = std::min_element(std::begin(distances), std::end(distances));
 int index_closest = std::distance(std::begin(distances), min_distance);
 
  // Fill true pT and DeltaR if at least one truth object
  if (truth_particles.size() > 0){		
    tthtree->get_address<float *>(name_pt_branch)[n] = truth_particles[index_closest]->pt();
    tthtree->get_address<float *>(name_dr_branch)[n] = *min_distance;
    tthtree->get_address<int *>(  name_i_branch)[n]  = index_closest;
  }
  // Otherwise use dummy values
  else{
    tthtree->get_address<float *>(name_pt_branch)[n] = DEF_VAL_FLOAT;
    tthtree->get_address<float *>(name_dr_branch)[n] = 9999.0;
    tthtree->get_address<int *>(  name_i_branch)[n]  = DEF_VAL_INT;
  }

}//fill_truth_matching


// Function to fill the branches for a fatjet collection
// This needs to be templated as we can have either PFJets or BasicJet 
// objects as fatjets
template <typename JetType, typename CollectionType>
void fill_fatjet_branches(const edm::Event& iEvent, 
			  TTHTree* tthtree,
 			  const edm::EDGetTokenT<CollectionType> fj_token,
			  edm::EDGetTokenT<edm::ValueMap<float>> fatjetNsubTau1Token,
			  edm::EDGetTokenT<edm::ValueMap<float>> fatjetNsubTau2Token,
			  edm::EDGetTokenT<edm::ValueMap<float>> fatjetNsubTau3Token,
			  edm::EDGetTokenT<edm::ValueMap<double>> fatjetSDChi1Token,
			  edm::EDGetTokenT<edm::ValueMap<double>> fatjetSDChi2Token,
			  edm::EDGetTokenT<edm::ValueMap<double>> fatjetSDChi3Token,
			  edm::EDGetTokenT<edm::ValueMap<int>> fatjetSDNMJ1Token,
			  edm::EDGetTokenT<edm::ValueMap<int>> fatjetSDNMJ2Token,
			  edm::EDGetTokenT<edm::ValueMap<int>> fatjetSDNMJ3Token,			  		 	  
			  edm::EDGetTokenT<reco::JetTagCollection> fatjetBtagsToken,			  		 	  
			  edm::EDGetTokenT<edm::ValueMap<float>> fatjetQvolsToken,			  		 	 
			  edm::EDGetTokenT<reco::JetFlavourInfoMatchingCollection> fatjetFlavInfoToken,
			  edm::EDGetTokenT<reco::JetCorrector> jetCorrectorToken,
			  std::string fj_nsubs_name,
			  std::string fj_sds_name,
			  std::string fj_btags_name,
			  std::string fj_qvols_name,
			  std::string fj_branches_name,
			  std::string fj_flavour_info_name,
			  std::string fj_corrector_name,
			  // true top and anti top for optional matching
			  const vector<const reco::Candidate*>  & true_t,
			  // hard partons for matching
			  const vector<const reco::Candidate*>  & hard_partons,
			  // true higgs for matching
			  const vector<const reco::Candidate*>  & gen_higgs){
  
  // Get Fatjet iteself    
  edm::Handle<CollectionType>  fatjets;
  iEvent.getByToken(fj_token, fatjets);

  // Handles to get the Nsubjettiness
  edm::Handle<edm::ValueMap<float> > fatjet_nsub_tau1;
  edm::Handle<edm::ValueMap<float> > fatjet_nsub_tau2;
  edm::Handle<edm::ValueMap<float> > fatjet_nsub_tau3;
  if (fj_nsubs_name != "None"){
    iEvent.getByToken(fatjetNsubTau1Token, fatjet_nsub_tau1);
    iEvent.getByToken(fatjetNsubTau2Token, fatjet_nsub_tau2);
    iEvent.getByToken(fatjetNsubTau3Token, fatjet_nsub_tau3);

    // Make sure the fatjets and nsujettiness containers have same size
    assert(fatjets->size()==fatjet_nsub_tau1->size());
    assert(fatjets->size()==fatjet_nsub_tau2->size());
    assert(fatjets->size()==fatjet_nsub_tau3->size());  
  }


  // Handle to get the Shower Deconstruction info
  edm::Handle<edm::ValueMap<double> > fatjet_sd_chi1;
  edm::Handle<edm::ValueMap<int> > fatjet_sd_nmj1;
  edm::Handle<edm::ValueMap<double> > fatjet_sd_chi2;
  edm::Handle<edm::ValueMap<int> > fatjet_sd_nmj2;
  edm::Handle<edm::ValueMap<double> > fatjet_sd_chi3;
  edm::Handle<edm::ValueMap<int> > fatjet_sd_nmj3;
  if (fj_sds_name != "None"){

    iEvent.getByToken(fatjetSDChi1Token, fatjet_sd_chi1);
    iEvent.getByToken(fatjetSDNMJ1Token, fatjet_sd_nmj1);

    iEvent.getByToken(fatjetSDChi2Token, fatjet_sd_chi2);
    iEvent.getByToken(fatjetSDNMJ2Token, fatjet_sd_nmj2);

    iEvent.getByToken(fatjetSDChi3Token, fatjet_sd_chi3);
    iEvent.getByToken(fatjetSDNMJ3Token, fatjet_sd_nmj3);
  }

  // b-tag discriminators handle
  edm::Handle<reco::JetTagCollection> btagDiscriminators;
  if (fj_btags_name != "None"){
    iEvent.getByToken(fatjetBtagsToken, btagDiscriminators);    
  }

  // Q-jet volatility handle
  edm::Handle<edm::ValueMap<float> > QjetVols;
  if (fj_qvols_name != "None")
    iEvent.getByToken(fatjetQvolsToken, QjetVols);

  // Flavour Info handle
  edm::Handle<reco::JetFlavourInfoMatchingCollection> JetFlavourInfos;
  if (fj_flavour_info_name != "None"){
    iEvent.getByToken(fatjetFlavInfoToken, JetFlavourInfos);
  }

  // JetCorrector
  edm::Handle<reco::JetCorrector> corrector;
  if (fj_corrector_name != "None")
    iEvent.getByToken(jetCorrectorToken, corrector);

  // Loop over fatjets
  for (unsigned n_fat_jet = 0; n_fat_jet != fatjets->size(); n_fat_jet++){
	    
    const JetType& x = (*fatjets).at(n_fat_jet);
    
    LogDebug("fat jets") << "n_fat_jet=" << n_fat_jet << CANDPRINT(x);
	    	    
    std::string prefix("jet_");
    prefix.append(fj_branches_name);
    prefix.append("__");

    // Get the correction factor for this jet
    float corr_factor = 1;
    if (fj_corrector_name != "None")
      corr_factor = corrector->correction(x);

    // Turn the branch address into the actual object we want to fill
    tthtree->get_address<float *>(prefix + "pt"  )[n_fat_jet] = x.pt();
    tthtree->get_address<float *>(prefix + "eta" )[n_fat_jet] = x.eta();
    tthtree->get_address<float *>(prefix + "phi" )[n_fat_jet] = x.phi();
    tthtree->get_address<float *>(prefix + "mass")[n_fat_jet] = x.mass();

    tthtree->get_address<float *>(prefix + "masscal")[n_fat_jet] = x.mass() * corr_factor;
    
    // Constituents
    tthtree->get_address<int *>(prefix + "nconst")[n_fat_jet] = x.getJetConstituents().size();
    tthtree->get_address<int *>(prefix + "ncharged")[n_fat_jet] = x.chargedMultiplicity();
    tthtree->get_address<int *>(prefix + "nneutral")[n_fat_jet] = x.neutralMultiplicity();


    // NSubjettiness
    if (fj_nsubs_name != "None"){
      tthtree->get_address<float *>(prefix + "tau1")[n_fat_jet] = fatjet_nsub_tau1->get(n_fat_jet);
      tthtree->get_address<float *>(prefix + "tau2")[n_fat_jet] = fatjet_nsub_tau2->get(n_fat_jet);
      tthtree->get_address<float *>(prefix + "tau3")[n_fat_jet] = fatjet_nsub_tau3->get(n_fat_jet);
    }     

    // Shower Deconstruction
    if (fj_sds_name != "None"){
      tthtree->get_address<float *>(prefix + "chi1")[n_fat_jet] = fatjet_sd_chi1->get(n_fat_jet);
      tthtree->get_address<int *>(prefix   + "nmj1")[n_fat_jet] = fatjet_sd_nmj1->get(n_fat_jet);

      tthtree->get_address<float *>(prefix + "chi2")[n_fat_jet] = fatjet_sd_chi2->get(n_fat_jet);
      tthtree->get_address<int *>(prefix   + "nmj2")[n_fat_jet] = fatjet_sd_nmj2->get(n_fat_jet);

      tthtree->get_address<float *>(prefix + "chi3")[n_fat_jet] = fatjet_sd_chi3->get(n_fat_jet);
      tthtree->get_address<int *>(prefix   + "nmj3")[n_fat_jet] = fatjet_sd_nmj3->get(n_fat_jet);
    }

    // B-tag
    if (fj_btags_name != "None"){
      tthtree->get_address<float *>(prefix + "btag")[n_fat_jet] = (*btagDiscriminators)[n_fat_jet].second;
    }

    // Q-jet volatility
    if (fj_qvols_name != "None")
      tthtree->get_address<float *>(prefix + "qvol")[n_fat_jet] = QjetVols->get(n_fat_jet);
   
    // Flavour Info
    if (fj_flavour_info_name != "None"){
      
      reco::JetFlavourInfo aInfo = (*JetFlavourInfos)[n_fat_jet].second;

      tthtree->get_address<float *>(prefix + "hadflavour")[n_fat_jet] = aInfo.getHadronFlavour();
      tthtree->get_address<float *>(prefix + "partflavour")[n_fat_jet] = aInfo.getPartonFlavour();      
    }

    // Optional: Fill truth matching information
    if (ADD_TRUE_TOP_MATCHING_FOR_FJ)
      fill_truth_matching<JetType>(tthtree, x, n_fat_jet, true_t, prefix, "hadtop");
    if (ADD_TRUE_PARTON_MATCHING_FOR_FJ)	      
      fill_truth_matching<JetType>(tthtree, x, n_fat_jet, hard_partons, prefix, "parton");
    if (ADD_TRUE_HIGGS_MATCHING_FOR_FJ)	      
      fill_truth_matching<JetType>(tthtree, x, n_fat_jet, gen_higgs, prefix, "higgs");
        
  }// End loop over fatjets
  
  // Also count the number of fatjets
  std::string njet_branch("n__jet_" + fj_branches_name);
  *(tthtree->get_address<int *>(njet_branch)) = fatjets->size();  
}


// Function to fill the branches for a  truth collection
// (higgs, hadronic tops or partons)
// objects as fatjets
void fill_genparticle_branches(TTHTree* tthtree, 
			       const vector<const reco::Candidate*>  & particles,
			       std::string name){
  
  // Loop over particles
  for (vector<const reco::Candidate*>::const_iterator it = particles.begin();
       it != particles.end();
       ++it){
    
    std::string prefix("gen_");
    prefix.append(name);
    prefix.append("__");

    int n = it - particles.begin();
    
    // Fill the branches
    tthtree->get_address<float *>(prefix + "pt"  )[n]  = (*it)->pt();
    tthtree->get_address<float *>(prefix + "eta" )[n]  = (*it)->eta();
    tthtree->get_address<float *>(prefix + "phi" )[n]  = (*it)->phi();
    tthtree->get_address<float *>(prefix + "mass")[n]  = (*it)->mass();    
    tthtree->get_address<int   *>(prefix + "pdgid")[n] = (*it)->pdgId();    
    
  }
  
  // Also count the number of particles
  std::string n_branch("n__gen_" + name);
  *(tthtree->get_address<int *>(n_branch)) = particles.size();
}



class TTHNtupleAnalyzer : public edm::EDAnalyzer {

public:
	explicit TTHNtupleAnalyzer(const edm::ParameterSet&);
	~TTHNtupleAnalyzer();

	static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


private:
	virtual void beginJob() override;
	virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
	virtual void endJob() override;
	virtual void finalizeLoop();

	const edm::EDGetTokenT<std::vector<reco::GenJet>> genJetToken_;        
  	const edm::EDGetTokenT<GenEventInfoProduct>  genEventInfoToken_;
  	const edm::EDGetTokenT<std::vector<PileupSummaryInfo> > pupInfoToken_;

	// collection of vertices
	const edm::EDGetTokenT<reco::VertexCollection> vertexToken_;


	// truth info



	const edm::EDGetTokenT<edm::View<reco::GenParticle> > prunedGenToken_;
	const edm::EDGetTokenT<edm::View<pat::PackedGenParticle> > packedGenToken_;


        // HTT tokens
        std::vector<edm::EDGetTokenT< edm::View<reco::BasicJet> > > httTokens_;
        std::vector<edm::EDGetTokenT< edm::View<reco::HTTTopJetTagInfo> > > httInfoTokens_;

        // CMSTT tokens
        std::vector<edm::EDGetTokenT< edm::View<reco::BasicJet> > > cmsttTokens_;
        std::vector<edm::EDGetTokenT< edm::View<reco::CATopJetTagInfo> > > cmsttInfoTokens_;
        std::vector<edm::EDGetTokenT< reco::JetTagCollection>> cmsttBtagsTokens_;
    
        // fatjet information
        // objects = name of the jet collection
        // nsubs = name of the N-subjettiness calculation process
        // sds = name of the Shower Deconstruction calculation process (or None)
        // btags = name of the btagger processes (or None) 
        // qvols = name of the QJet volatility processes (or None) 
        // fatjet branches = name of the branches to put this in
        // usesubjets = either use that jet object or the "SubJets" field
        // !!the lists have to be in sync!!
	const std::vector<std::string> fatjet_objects_;
	const std::vector<std::string> fatjet_nsubs_;
	const std::vector<std::string> fatjet_sds_;
	const std::vector<std::string> fatjet_btags_;
	const std::vector<std::string> fatjet_qvols_;
	const std::vector<std::string> fatjet_branches_;
	const std::vector<int> fatjet_usesubjets_;
  	const std::vector<std::string> fatjet_flavour_infos_;
  	const std::vector<std::string> fatjet_correctors_;

        // Fatjet Tokens
        std::vector<edm::EDGetTokenT< reco::PFJetCollection > > fatjetTokens_;
       
        std::vector<edm::EDGetTokenT<edm::ValueMap<float>>> fatjetNsubTau1Tokens_;
        std::vector<edm::EDGetTokenT<edm::ValueMap<float>>> fatjetNsubTau2Tokens_;
        std::vector<edm::EDGetTokenT<edm::ValueMap<float>>> fatjetNsubTau3Tokens_;

        std::vector<edm::EDGetTokenT<edm::ValueMap<double>>> fatjetSDChi1Tokens_;
        std::vector<edm::EDGetTokenT<edm::ValueMap<double>>> fatjetSDChi2Tokens_;
        std::vector<edm::EDGetTokenT<edm::ValueMap<double>>> fatjetSDChi3Tokens_;

        std::vector<edm::EDGetTokenT<edm::ValueMap<int>>> fatjetSDNMJ1Tokens_;
        std::vector<edm::EDGetTokenT<edm::ValueMap<int>>> fatjetSDNMJ2Tokens_;
        std::vector<edm::EDGetTokenT<edm::ValueMap<int>>> fatjetSDNMJ3Tokens_;
        
        std::vector<edm::EDGetTokenT<reco::JetTagCollection>> fatjetBtagsTokens_;
        std::vector<edm::EDGetTokenT<edm::ValueMap<float>>> fatjetQvolsTokens_;			  		 	  
        std::vector<edm::EDGetTokenT<reco::JetFlavourInfoMatchingCollection>> fatjetFlavInfoTokens_;
        
        std::vector<edm::EDGetTokenT<reco::JetCorrector>> jetCorrectorTokens_;
  
        // HEPTopTagger information
        // objects = name of the input collection
        // htt branches = name of the branches to put this in
        // !!the lists have to be in sync!!
	const std::vector<std::string> htt_objects_;
	const std::vector<std::string> htt_branches_;

        // CMSTopTagger information
        // objects = name of the input jet collection
        // infos = name of the input info collection
        // cmstt branches = name of the branches to put this in
        // !!the lists have to be in sync!!
	const std::vector<std::string> cmstt_objects_;
	const std::vector<std::string> cmstt_infos_;
	const std::vector<std::string> cmstt_branches_;
	const std::vector<std::string> cmstt_btags_;
	
	// LHE event product (may not be present!!)
	const edm::EDGetTokenT<LHEEventProduct> lheToken_;

	// the output tree
	TTHTree* tthtree;
	TNamed* config_dump;
	const edm::Service<TFileService> fs;

	//a histogram with event counts	
	TH1D* hcounter;

	// a watch for CPU monitoring
	TStopwatch* sw;

	// parameters
	const bool		isMC_;
  	const double	genPartonPt_min_;
        const int       genPartonStatus_;

};


TTHNtupleAnalyzer::TTHNtupleAnalyzer(const edm::ParameterSet& iConfig) :

	genJetToken_(consumes<std::vector<reco::GenJet>>(iConfig.getParameter<edm::InputTag>("genjets"))),

	genEventInfoToken_(consumes<GenEventInfoProduct>(iConfig.getParameter<edm::InputTag>("generator"))),
        pupInfoToken_(consumes<std::vector<PileupSummaryInfo> >(iConfig.getParameter<edm::InputTag>("pupInfo"))),
						   
	vertexToken_(consumes<reco::VertexCollection>(iConfig.getParameter<edm::InputTag>("vertices"))),
	prunedGenToken_(consumes<edm::View<reco::GenParticle> >(iConfig.getParameter<edm::InputTag>("pruned"))),
	packedGenToken_(consumes<edm::View<pat::PackedGenParticle> >(iConfig.getParameter<edm::InputTag>("packed"))),

	       					  
        fatjet_objects_(iConfig.getParameter<std::vector<std::string>>("fatjetsObjects")),
        fatjet_nsubs_(iConfig.getParameter<std::vector<std::string>>("fatjetsNsubs")),
        fatjet_sds_(iConfig.getParameter<std::vector<std::string>>("fatjetsSDs")),
        fatjet_btags_(iConfig.getParameter<std::vector<std::string>>("fatjetsBtags")),
        fatjet_qvols_(iConfig.getParameter<std::vector<std::string>>("fatjetsQvols")),
        fatjet_branches_(iConfig.getParameter<std::vector<std::string>>("fatjetsBranches")),
        fatjet_usesubjets_(iConfig.getParameter<std::vector<int>>("fatjetsUsesubjets")),
        fatjet_flavour_infos_(iConfig.getParameter<std::vector<std::string>>("fatjetsFlavourInfos")),
        fatjet_correctors_(iConfig.getParameter<std::vector<std::string>>("fatjetsCorrectors")),
      
        htt_objects_(iConfig.getParameter<std::vector<std::string>>("httObjects")),
        htt_branches_(iConfig.getParameter<std::vector<std::string>>("httBranches")),

        cmstt_objects_(iConfig.getParameter<std::vector<std::string>>("cmsttObjects")),
        cmstt_infos_(iConfig.getParameter<std::vector<std::string>>("cmsttInfos")),
        cmstt_branches_(iConfig.getParameter<std::vector<std::string>>("cmsttBranches")),
        cmstt_btags_(iConfig.getParameter<std::vector<std::string>>("cmsttBtags")),
							  
	//Gen-level
	lheToken_( (iConfig.getParameter<edm::InputTag>("lhe")).label()!="" ?
			consumes<LHEEventProduct>( iConfig.getParameter<edm::InputTag>("lhe")) : edm::EDGetTokenT<LHEEventProduct>() ),


	//output
	tthtree(new TTHTree(fs->make<TTree>("events", "events"))),
	config_dump(fs->make<TNamed>("configdump", iConfig.dump().c_str())),
	hcounter(fs->make<TH1D>("event_counter", "event_counter", 5, 0, 5)),
	
	//cuts
	isMC_(iConfig.getParameter<bool>("isMC")),
	genPartonPt_min_(iConfig.getUntrackedParameter<double>("genPartonPt_min", 200.)),
        genPartonStatus_(iConfig.getUntrackedParameter<int>("genPartonStatus", 23)){

  // Produce HTT Tokens
  for (unsigned int i=0; i < htt_objects_.size(); i++){
    edm::InputTag it(htt_objects_[i],"");
    httTokens_.push_back( consumes<edm::View<reco::BasicJet> >(it));    
    httInfoTokens_.push_back( consumes<edm::View<reco::HTTTopJetTagInfo> >(it));    
  }

  // Produce CMSTT Tokens
  for (unsigned int i=0; i < cmstt_objects_.size(); i++){
    edm::InputTag it(cmstt_objects_[i],"");
    cmsttTokens_.push_back( consumes<edm::View<reco::BasicJet> >(it));    
  }

  // Produce CMSTT Info Tokens
  for (unsigned int i=0; i < cmstt_infos_.size(); i++){
    edm::InputTag it(cmstt_infos_[i],"");
    cmsttInfoTokens_.push_back( consumes<edm::View<reco::CATopJetTagInfo> >(it));    
  }

  // Produce CMSTT Btag Tokens
  for (unsigned int i=0; i < cmstt_btags_.size(); i++){
    edm::InputTag it(cmstt_btags_[i],"");
    cmsttBtagsTokens_.push_back( consumes<reco::JetTagCollection>(it));    
  }

  // Produce Subjet Tokens
  for (unsigned int i=0; i < fatjet_objects_.size(); i++){
    edm::InputTag it;

    if (fatjet_usesubjets_[i] == 1)
      it = edm::InputTag(fatjet_objects_[i],"SubJets");
    else
      it = edm::InputTag(fatjet_objects_[i],"");

    fatjetTokens_.push_back(consumes<reco::PFJetCollection>(it));    
  }

  // Produce NSubjettiness Tokens
  for (unsigned int i=0; i < fatjet_nsubs_.size(); i++){    
        edm::InputTag it1(fatjet_nsubs_[i],"tau1");
        edm::InputTag it2(fatjet_nsubs_[i],"tau2");
        edm::InputTag it3(fatjet_nsubs_[i],"tau3");
	
	fatjetNsubTau1Tokens_.push_back(consumes<edm::ValueMap<float>>(it1));
	fatjetNsubTau2Tokens_.push_back(consumes<edm::ValueMap<float>>(it2));
	fatjetNsubTau3Tokens_.push_back(consumes<edm::ValueMap<float>>(it3));           
  }

  // Produce Shower Deconstruction Tokens
  for (unsigned int i=0; i < fatjet_sds_.size(); i++){

    std::string sd1_label = fatjet_sds_[i];
    std::string sd2_label = fatjet_sds_[i];
    std::string sd3_label = fatjet_sds_[i];    

    sd1_label.append("1");
    sd2_label.append("2");
    sd3_label.append("3");
   
    edm::InputTag it_chi1(sd1_label,"chi");
    edm::InputTag it_chi2(sd2_label,"chi");
    edm::InputTag it_chi3(sd3_label,"chi");

    edm::InputTag it_nmj1(sd1_label,"nmicrojets");
    edm::InputTag it_nmj2(sd2_label,"nmicrojets");
    edm::InputTag it_nmj3(sd3_label,"nmicrojets");

    fatjetSDChi1Tokens_.push_back(consumes<edm::ValueMap<double>>(it_chi1));
    fatjetSDChi2Tokens_.push_back(consumes<edm::ValueMap<double>>(it_chi2));
    fatjetSDChi3Tokens_.push_back(consumes<edm::ValueMap<double>>(it_chi3));
    fatjetSDNMJ1Tokens_.push_back(consumes<edm::ValueMap<int>>(it_nmj1));
    fatjetSDNMJ2Tokens_.push_back(consumes<edm::ValueMap<int>>(it_nmj2));
    fatjetSDNMJ3Tokens_.push_back(consumes<edm::ValueMap<int>>(it_nmj3));      
  }

  // Produce Fatjet/Btag tokens
  for (unsigned int i=0; i < fatjet_btags_.size(); i++){
    edm::InputTag it(fatjet_btags_[i],"");
    fatjetBtagsTokens_.push_back(consumes<reco::JetTagCollection>(it));    
  }

  // Produce Q-jet volatility tokens
  for (unsigned int i=0; i < fatjet_qvols_.size(); i++){
    edm::InputTag it(fatjet_qvols_[i],"");
    fatjetQvolsTokens_.push_back(consumes<edm::ValueMap<float>>(it));
  }
  
  // Produce jet flavour info tokens
  for (unsigned int i=0; i < fatjet_flavour_infos_.size(); i++){
    edm::InputTag it(fatjet_flavour_infos_[i],"");
    fatjetFlavInfoTokens_.push_back(consumes<reco::JetFlavourInfoMatchingCollection>(it));
  }

  // Produce jet corrector info tokens
  for (unsigned int i=0; i < fatjet_correctors_.size(); i++){
    edm::InputTag it(fatjet_correctors_[i],"");
    jetCorrectorTokens_.push_back(consumes<reco::JetCorrector>(it));
  }
  
  tthtree->make_branches();
  
  hcounter->GetXaxis()->SetBinLabel(1, "TTHNtupleAnalyzer__processed");
  hcounter->GetXaxis()->SetBinLabel(2, "TTHNtupleAnalyzer__passed");
  
  sw = new TStopwatch();
}


TTHNtupleAnalyzer::~TTHNtupleAnalyzer()
{
	delete sw;
}

void TTHNtupleAnalyzer::finalizeLoop() {
}

// ------------ method called for each event ------------
void
TTHNtupleAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
	//fill analyzed
	hcounter->SetBinContent(1, hcounter->GetBinContent(1)+1);
	using namespace edm;

	sw->Start();
	tthtree->loop_initialize();

	tthtree->event__id = (unsigned int)iEvent.id().event();
	tthtree->event__run = (unsigned int)iEvent.id().run();
	tthtree->event__lumi = (unsigned int)iEvent.id().luminosityBlock();

	//Primary vertices
	edm::Handle<reco::VertexCollection> vertices;
	iEvent.getByToken(vertexToken_, vertices);
	if (vertices->empty()) {
		edm::LogError("loop") << "no vertices found";
		finalizeLoop();
		return;
	}

	tthtree->n__pv = vertices->size();

	if (isMC_) {
	
	// MC Event Weight
	edm::Handle<GenEventInfoProduct> genEvtInfo ;


	iEvent.getByToken(genEventInfoToken_, genEvtInfo);
	tthtree->weight__genmc = genEvtInfo->weight();
	

	 
	Handle<edm::View<reco::GenParticle> > pruned;
	
	//Pileup and genparticles
		Handle<std::vector<PileupSummaryInfo>> PupInfo;
		iEvent.getByToken(pupInfoToken_, PupInfo);
		std::vector<PileupSummaryInfo>::const_iterator PVI;
		tthtree->n__pvi = PupInfo->size();
		int n_pu = 0;
		for (PVI = PupInfo->begin(); PVI != PupInfo->end(); ++PVI)
		{
			const int BX = PVI->getBunchCrossing();
			LogDebug("PVI") << n_pu << " BX=" << BX;
			tthtree->pvi__n0[n_pu] = PVI->getPU_NumInteractions();
			tthtree->pvi__bx[n_pu] = BX;
			if (BX == 0)
			{
				tthtree->pvi__ntrue[n_pu] = PVI->getTrueNumInteractions();
			}
			n_pu += 1;
		}
	}

	// Sanity check the fatjet lists-of-names
	assert(fatjet_objects_.size()==fatjet_nsubs_.size());
	assert(fatjet_objects_.size()==fatjet_sds_.size());
	assert(fatjet_objects_.size()==fatjet_btags_.size());
	assert(fatjet_objects_.size()==fatjet_qvols_.size());
	assert(fatjet_objects_.size()==fatjet_branches_.size());
	assert(fatjet_objects_.size()==fatjet_usesubjets_.size());
	assert(fatjet_objects_.size()==fatjet_flavour_infos_.size());
	assert(fatjet_objects_.size()==fatjet_correctors_.size());

	// Sanity check the htt lists-of-names
	assert(htt_objects_.size()==htt_branches_.size());

	// Sanity check the cmstt lists-of-names
	assert(cmstt_objects_.size()==cmstt_branches_.size());
	assert(cmstt_objects_.size()==cmstt_infos_.size());
	assert(cmstt_objects_.size()==cmstt_btags_.size());
	       	
	Handle<edm::View<reco::GenParticle> > pruned;
	if (isMC_) 
	  iEvent.getByToken(prunedGenToken_,pruned);



	// These quantities will be filled by gen_association
	// Last Tops in Chain
	vector<const reco::GenParticle*> tops_last;
	vector<const reco::GenParticle*> antitops_last;
	// First Tops in Chain
	vector<const reco::Candidate*> tops_first;
	vector<const reco::Candidate*> antitops_first;
	vector<const reco::GenParticle*> bquarks;
	vector<const reco::GenParticle*> antibquarks;
	
	// Hard partons (usually for QCD matching)
	vector<const reco::Candidate*> hard_partons;

	// Higgs Bosons
	double min_higgs_pt = 0.; 
	vector<const reco::Candidate*> gen_higgs;

	if (isMC_) {
	  gen_association(pruned, 
			  tthtree,
			  tops_last,
			  antitops_last,
			  tops_first,
			  antitops_first,
			  bquarks,
			  antibquarks);	  

	  if (ADD_TRUE_PARTON_MATCHING_FOR_FJ || ADD_TRUE_PARTON_MATCHING_FOR_HTT || ADD_TRUE_PARTON_MATCHING_FOR_CMSTT)
	    get_hard_partons(pruned, genPartonPt_min_, genPartonStatus_, hard_partons);

	  if (ADD_TRUE_HIGGS_MATCHING_FOR_FJ || ADD_TRUE_HIGGS_MATCHING_FOR_HTT || ADD_TRUE_HIGGS_MATCHING_FOR_CMSTT)
	    get_gen_higgs(pruned, min_higgs_pt, gen_higgs);

	}	

	// Combine tops and antitops for truth matching
	vector<const reco::Candidate*> tops_antitops_last; // empty list
	tops_antitops_last.insert(tops_antitops_last.end(), tops_last.begin(), tops_last.end()); // add tops
	tops_antitops_last.insert(tops_antitops_last.end(), antitops_last.begin(), antitops_last.end()); // add antis

	// Hadronically decaying top quarks - only take the ones passing the pT threshold
	float min_true_top_pt = 200;
	vector<const reco::Candidate*> hadronic_ts;
	for (vector<const reco::Candidate*>::const_iterator iter = tops_antitops_last.begin();
	     iter != tops_antitops_last.end();
	     ++iter){	  	  
	  if ( (is_hadronic_top(*iter) == 1) &&   // Check hadronic decay
	       ((*iter)->pt() > min_true_top_pt)) // Check pT
	    hadronic_ts.push_back(*iter);
	}

	// Sort the truth top/higgs/parton collections by pT descending 
	sort(hard_partons.begin(), hard_partons.end(), order_by_pt<const reco::Candidate*>);
	sort(gen_higgs.begin(),    gen_higgs.end(),    order_by_pt<const reco::Candidate*>);
	sort(hadronic_ts.begin(),  hadronic_ts.end(),  order_by_pt<const reco::Candidate*>);

	// Fill the genparticle branches
	fill_genparticle_branches(tthtree, hard_partons, "parton");
	fill_genparticle_branches(tthtree, gen_higgs,    "higgs");
	fill_genparticle_branches(tthtree, hadronic_ts,  "hadtop");
  
            	
	// Loop over HTT collections
	for (unsigned i_htt_coll = 0; i_htt_coll < htt_objects_.size(); i_htt_coll++){

	
	  // Get the proper names
	  std::string htt_object_name   = htt_objects_[i_htt_coll];
	  std::string htt_branches_name = htt_branches_[i_htt_coll];
 	  
	  // Top tagger jets
	  edm::Handle<edm::View<reco::BasicJet>> top_jets;
	  iEvent.getByToken(httTokens_[i_htt_coll], top_jets);

	  // Extra Info
	  edm::Handle<edm::View<reco::HTTTopJetTagInfo>> top_jet_infos;
	  iEvent.getByToken(httInfoTokens_[i_htt_coll], top_jet_infos);

	  // Make sure both collections have the same size
	  assert(top_jets->size()==top_jet_infos->size());

	  //edm::Handle<edm::View<reco::PFJet>> calibrated_htt_subjets;
	  //iEvent.getByLabel("foojets", calibrated_htt_subjets);

	  //std::vector<reco::PFJet> foo;

	  //for (unsigned int i_cal_sj=0; i_cal_sj<calibrated_htt_subjets->size(); i_cal_sj++) {
	  //  foo.push_back( (*calibrated_htt_subjets)[i_cal_sj]);
	  //}

          // HEPTopTagger
	  // Top jets and subjets are associated by indices. See:
	  // /cvmfs/cms.cern.ch/slc6_amd64_gcc481/cms/cmssw/CMSSW_7_0_9/src/RecoJets/JetProducers/plugins/CompoundJetProducer.cc
	  // about the association
	  int n_top_jet_subjet = 0;

	  // Loop over top candidates
	  for (unsigned int n_top_jet=0; n_top_jet<top_jets->size(); n_top_jet++) {

	    const reco::BasicJet& x = top_jets->at(n_top_jet);
	    const reco::HTTTopJetTagInfo& jet_info = top_jet_infos->at(n_top_jet);

	    LogDebug("top jets") << "n_top_jet=" << n_top_jet << CANDPRINT(x);

	    std::string prefix("jet_");
	    prefix.append(htt_branches_name);
	    prefix.append("__");

	    tthtree->get_address<float *>(prefix + "eta"    )[n_top_jet] = x.eta();
	    tthtree->get_address<float *>(prefix + "pt"     )[n_top_jet] = x.pt();
	    tthtree->get_address<float *>(prefix + "phi"    )[n_top_jet] = x.phi();
	    tthtree->get_address<float *>(prefix + "mass"   )[n_top_jet] = x.mass();

	    tthtree->get_address<float *>(prefix + "fj_pt"   )[n_top_jet] = jet_info.properties().fjPt;
	    tthtree->get_address<float *>(prefix + "fj_mass" )[n_top_jet] = jet_info.properties().fjMass;
	    tthtree->get_address<float *>(prefix + "fj_eta"  )[n_top_jet] = jet_info.properties().fjEta;
	    tthtree->get_address<float *>(prefix + "fj_phi"  )[n_top_jet] = jet_info.properties().fjPhi;

	    tthtree->get_address<float *>(prefix + "topMass" )[n_top_jet] = jet_info.properties().topMass;

	    tthtree->get_address<float *>(prefix + "unfilteredMass" )[n_top_jet] = jet_info.properties().unfilteredMass;
	    tthtree->get_address<float *>(prefix + "prunedMass" )[n_top_jet]	 = jet_info.properties().prunedMass;
	    tthtree->get_address<float *>(prefix + "fRec" )[n_top_jet]		 = jet_info.properties().fRec;

	    tthtree->get_address<float *>(prefix + "massRatioPassed" )[n_top_jet]  = jet_info.properties().massRatioPassed;

	    tthtree->get_address<float *>(prefix + "Ropt" )[n_top_jet]		= jet_info.properties().Ropt;
	    tthtree->get_address<float *>(prefix + "RoptCalc" )[n_top_jet]	= jet_info.properties().RoptCalc;
	    tthtree->get_address<float *>(prefix + "ptForRoptCalc" )[n_top_jet] = jet_info.properties().ptForRoptCalc;

	    tthtree->get_address<float *>(prefix + "tau1unfilt" )[n_top_jet]	= jet_info.properties().tau1Unfiltered;
	    tthtree->get_address<float *>(prefix + "tau2unfilt" )[n_top_jet]	= jet_info.properties().tau2Unfiltered;
	    tthtree->get_address<float *>(prefix + "tau3unfilt" )[n_top_jet]	= jet_info.properties().tau3Unfiltered;

	    tthtree->get_address<float *>(prefix + "tau1filt" )[n_top_jet]	= jet_info.properties().tau1Filtered;
	    tthtree->get_address<float *>(prefix + "tau2filt" )[n_top_jet]	= jet_info.properties().tau2Filtered;
	    tthtree->get_address<float *>(prefix + "tau3filt" )[n_top_jet]	= jet_info.properties().tau3Filtered;

	    tthtree->get_address<float *>(prefix + "qweight" )[n_top_jet]	= jet_info.properties().QWeight;
	    tthtree->get_address<float *>(prefix + "qepsilon")[n_top_jet]	= jet_info.properties().QEpsilon;
	    tthtree->get_address<float *>(prefix + "qsigmam" )[n_top_jet]	= jet_info.properties().QSigmaM;

	    tthtree->get_address<int *>(prefix + "n_sj" )[n_top_jet]  = 3;
	   
	    // Optional: Fill truth matching information
	    if (ADD_TRUE_TOP_MATCHING_FOR_HTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hadronic_ts, prefix, "hadtop");
	    if (ADD_TRUE_PARTON_MATCHING_FOR_HTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hard_partons, prefix, "parton");
	    if (ADD_TRUE_HIGGS_MATCHING_FOR_HTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, gen_higgs, prefix, "higgs");
	    
	    bool first = true;
	    for ( edm::Ptr<reco::Candidate > constituent : x.getJetConstituents()) {
	      if (constituent.isNull()) {
		edm::LogWarning("top jets") << "n_top_jet=" << n_top_jet << " constituent is not valid";
		break;
	      }
	      if (first) {
	      	tthtree->get_address<int *>(prefix + "child_idx" )[n_top_jet]  = n_top_jet_subjet;
	      }
	      
	      std::string prefix_sj("jet_");
	      prefix_sj.append(htt_branches_name);
	      prefix_sj.append("_sj__");

	      tthtree->get_address<float *>(prefix_sj + "pt" )[n_top_jet_subjet]  = constituent->pt();
	      tthtree->get_address<float *>(prefix_sj + "eta" )[n_top_jet_subjet]  = constituent->eta();
	      tthtree->get_address<float *>(prefix_sj + "phi" )[n_top_jet_subjet]  = constituent->phi();
	      tthtree->get_address<float *>(prefix_sj + "mass" )[n_top_jet_subjet]  = constituent->mass();
	      tthtree->get_address<float *>(prefix_sj + "energy" )[n_top_jet_subjet]  = constituent->energy();

	      tthtree->get_address<int *>(prefix_sj + "parent_idx" )[n_top_jet_subjet]  = n_top_jet;

//	      std::sort(foo.begin(), foo.end(),  distance_sorter_p4<reco::PFJet>(constituent->p4()));
//		
//	      if (htt_object_name == "looseOptRHTT"){
//		std::cout << n_top_jet_subjet << ": " << (foo)[0].pt() <<
//		  " " <<
//		  constituent->pt() <<
//		  " " <<
//		  (*calibrated_htt_subjets)[n_top_jet_subjet].eta() <<
//		  " " <<
//		  constituent->eta() <<
//		  " " <<
//		  (*calibrated_htt_subjets)[n_top_jet_subjet].phi() <<
//		  " " <<
//		  constituent->phi() << std::endl;
//	      }
//	      
// 	  std::cout << "Number of calibrated subjets: " << ->// // size() << std::endl;
//	  // // std::cout << "Number of HTT Candidates: " << top_jets->size()
//		    << " for " <<  << std::endl<< std::endl;
//


	      n_top_jet_subjet += 1;	      
	      first = false;
	    }
	  } // End of loop over candidates

	  // Also fill counters	  
	  std::string ncand_branch("n__jet_");
	  ncand_branch.append(htt_branches_name);

	  std::string ncand_sj_branch("n__jet_");
	  ncand_sj_branch.append(htt_branches_name);
	  ncand_sj_branch.append("_sj");
	  
	  *(tthtree->get_address<int *>(ncand_branch ))    = top_jets->size();
	  *(tthtree->get_address<int *>(ncand_sj_branch )) = n_top_jet_subjet;

	} // End of filling HTT related branches

	
	// Loop over CMSTT collections
	for (unsigned i_cmstt_coll = 0; i_cmstt_coll < cmstt_objects_.size(); i_cmstt_coll++){

	  // Get the proper names
	  //std::string cmstt_object_name   = cmstt_objects_[i_cmstt_coll];
	  //std::string cmstt_infos_name    = cmstt_infos_[i_cmstt_coll];
	  std::string cmstt_branches_name = cmstt_branches_[i_cmstt_coll];
	  std::string cmstt_btags_name     = cmstt_btags_[i_cmstt_coll];
 	  

	  // Top tagger jets
	  edm::Handle<edm::View<reco::BasicJet>> top_jets;
	  iEvent.getByToken(cmsttTokens_[i_cmstt_coll], top_jets);

	  // Extra Info
	  edm::Handle<edm::View<reco::CATopJetTagInfo>> top_jet_infos;
	  iEvent.getByToken(cmsttInfoTokens_[i_cmstt_coll], top_jet_infos);
	  	  
	  // Make sure both collections have the same size
	  assert(top_jets->size()==top_jet_infos->size());

	  // b-tag discriminators handle
	  edm::Handle<reco::JetTagCollection> btagDiscriminators;
	  if (cmstt_btags_name != "None")
	    iEvent.getByToken(cmsttBtagsTokens_[i_cmstt_coll], btagDiscriminators);


	  // Top jets and subjets are associated by indices. See:
	  // /cvmfs/cms.cern.ch/slc6_amd64_gcc481/cms/cmssw/CMSSW_7_0_9/src/RecoJets/JetProducers/plugins/CompoundJetProducer.cc
	  // about the association
	  int n_top_jet_subjet = 0;

	  // Loop over top candidates
	  for (unsigned int n_top_jet=0; n_top_jet<top_jets->size(); n_top_jet++) {

	    const reco::BasicJet& x = top_jets->at(n_top_jet);
	    const reco::CATopJetTagInfo& jet_info = top_jet_infos->at(n_top_jet);

	    std::string prefix("jet_");
	    prefix.append(cmstt_branches_name);
	    prefix.append("__");

	    tthtree->get_address<float *>(prefix + "eta"    )[n_top_jet] = x.eta();
	    tthtree->get_address<float *>(prefix + "pt"     )[n_top_jet] = x.pt();
	    tthtree->get_address<float *>(prefix + "phi"    )[n_top_jet] = x.phi();
	    tthtree->get_address<float *>(prefix + "mass"   )[n_top_jet] = x.mass();

	    tthtree->get_address<float *>(prefix + "minMass" )[n_top_jet] = jet_info.properties().minMass;
	    tthtree->get_address<float *>(prefix + "wMass" )[n_top_jet] = jet_info.properties().wMass;
	    tthtree->get_address<float *>(prefix + "topMass" )[n_top_jet] = jet_info.properties().topMass;
	    tthtree->get_address<int   *>(prefix + "nSubJets" )[n_top_jet] = jet_info.properties().nSubJets;
	   	    
	    // Optional: Fill truth matching information
	    if (ADD_TRUE_TOP_MATCHING_FOR_CMSTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hadronic_ts, prefix, "hadtop");
	    if (ADD_TRUE_PARTON_MATCHING_FOR_CMSTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hard_partons, prefix, "parton");
	    if (ADD_TRUE_HIGGS_MATCHING_FOR_CMSTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, gen_higgs, prefix, "higgs");
	    
	    bool first = true;
	    for (auto& constituent : x.getJetConstituents()) {
	      if (constituent.isNull()) {
		edm::LogWarning("top jets") << "n_top_jet=" << n_top_jet << " constituent is not valid";
		break;
	      }
	      if (first) {
	      	tthtree->get_address<int *>(prefix + "child_idx" )[n_top_jet]  = n_top_jet_subjet;
	      }
	      
	      std::string prefix_sj("jet_");
	      prefix_sj.append(cmstt_branches_name);
	      prefix_sj.append("_sj__");

	      tthtree->get_address<float *>(prefix_sj + "pt" )[n_top_jet_subjet]  = constituent->pt();
	      tthtree->get_address<float *>(prefix_sj + "eta" )[n_top_jet_subjet]  = constituent->eta();
	      tthtree->get_address<float *>(prefix_sj + "phi" )[n_top_jet_subjet]  = constituent->phi();
	      tthtree->get_address<float *>(prefix_sj + "mass" )[n_top_jet_subjet]  = constituent->mass();
	      tthtree->get_address<float *>(prefix_sj + "energy" )[n_top_jet_subjet]  = constituent->energy();

	      // B-tag
	      if (cmstt_btags_name != "None"){
		tthtree->get_address<float *>(prefix_sj + "btag")[n_top_jet_subjet] = (*btagDiscriminators)[n_top_jet_subjet].second;
	      }

	      tthtree->get_address<int *>(prefix_sj + "parent_idx" )[n_top_jet_subjet]  = n_top_jet;

	      n_top_jet_subjet += 1;	      
	      first = false;
	    }
	  } // End of loop over candidates

	  // Also fill counters	  
	  std::string ncand_branch("n__jet_");
	  ncand_branch.append(cmstt_branches_name);

	  std::string ncand_sj_branch("n__jet_");
	  ncand_sj_branch.append(cmstt_branches_name);
	  ncand_sj_branch.append("_sj");
	  
	  *(tthtree->get_address<int *>(ncand_branch ))    = top_jets->size();
	  *(tthtree->get_address<int *>(ncand_sj_branch )) = n_top_jet_subjet;

	} // End of filling CMSTT related branches



	// Loop over fatjet collections
	for (unsigned i_fj_coll = 0; i_fj_coll < fatjet_objects_.size(); i_fj_coll++){

	  // Get the proper names
	  std::string	fj_btags_name	     = fatjet_btags_[i_fj_coll];
	  std::string	fj_qvols_name	     = fatjet_qvols_[i_fj_coll];
	  std::string	fj_branches_name     = fatjet_branches_[i_fj_coll];
	  std::string	fj_flavour_info_name = fatjet_flavour_infos_[i_fj_coll];
	  std::string	fj_corrector_name    = fatjet_correctors_[i_fj_coll];

	  fill_fatjet_branches<reco::PFJet, reco::PFJetCollection>(iEvent, 
								   tthtree, 
								   fatjetTokens_[i_fj_coll],
								   fatjetNsubTau1Tokens_[i_fj_coll], 
								   fatjetNsubTau2Tokens_[i_fj_coll],
								   fatjetNsubTau3Tokens_[i_fj_coll],
								   fatjetSDChi1Tokens_[i_fj_coll],
								   fatjetSDChi2Tokens_[i_fj_coll],
								   fatjetSDChi3Tokens_[i_fj_coll],
								   fatjetSDNMJ1Tokens_[i_fj_coll],
								   fatjetSDNMJ2Tokens_[i_fj_coll],
								   fatjetSDNMJ3Tokens_[i_fj_coll],
								   fatjetBtagsTokens_[i_fj_coll],
								   fatjetQvolsTokens_[i_fj_coll],
								   fatjetFlavInfoTokens_[i_fj_coll],
								   jetCorrectorTokens_[i_fj_coll],
								   fatjet_nsubs_[i_fj_coll],
								   fatjet_sds_[i_fj_coll],
								   fj_btags_name,
								   fj_qvols_name,
								   fj_branches_name,
								   fj_flavour_info_name,
								   fj_corrector_name,
								   hadronic_ts,
								   hard_partons,
								   gen_higgs);
	 
	} // End of loop over fatjet collections
	// Done filling the fatjet information



	//get the LHE gen-level stuff
	//code from LB --> LHE not always available
	if ( isMC_ ) {
		edm::Handle<LHEEventProduct> lhe;
		if( !lheToken_.isUninitialized() )
			iEvent.getByToken(lheToken_, lhe);

		if( lhe.isValid() ) {

			const lhef::HEPEUP hepeup_ = lhe->hepeup();
			const std::vector<lhef::HEPEUP::FiveVector> pup_ = hepeup_.PUP; // px, py, pz, E, M

			double lheHT = 0.0;
			unsigned int lheNj = 0;
			unsigned int countBquarks=0, countCquarks=0, countUDSquarks=0, countGquarks=0, countExtraPartons=0;
			for (unsigned int i=0; i<pup_.size(); ++i) {
				int id=hepeup_.IDUP[i]; //pdgId
				int status = hepeup_.ISTUP[i];
				int idabs=TMath::Abs(id);

				// gluons and quarks
				if(status == 1 && ((idabs == 21) || (idabs > 0 && idabs < 7))) {
					// first entry is px, second py
					lheHT += TMath::Sqrt( TMath::Power(hepeup_.PUP[i][0],2) + TMath::Power(hepeup_.PUP[i][1],2) );
					lheNj++;
				}

				if ( hepeup_.ISTUP[i] >= 0 && status == 1 ) {
					if (!(hepeup_.MOTHUP[i].first !=1 && hepeup_.MOTHUP[i].second !=2)) {
						if(idabs==5 ) countBquarks++;
						if(idabs==4 ) countCquarks++;
						if(idabs<=3 && idabs>=1 ) countUDSquarks++;
						if(idabs==21 ) countGquarks++;
						if(idabs==21 || (idabs>=1 && idabs<=5)) countExtraPartons++;
					}
				}
			}
			tthtree->lhe__ht = lheHT;
			tthtree->lhe__n_j = lheNj;
			tthtree->lhe__n_b = countBquarks;
			tthtree->lhe__n_c = countCquarks;
			tthtree->lhe__n_l = countUDSquarks;
			tthtree->lhe__n_g = countGquarks;
			tthtree->lhe__n_e = countExtraPartons;
		}
	} // isMC for LHE

	sw->Stop();
	tthtree->debug__time1r = sw->RealTime();
	tthtree->debug__time1c = sw->CpuTime();
	LogDebug("time") << "timing " << tthtree->debug__time1r << " " << tthtree->debug__time1c;
	tthtree->tree->Fill();
	
	//fill passed 
	hcounter->SetBinContent(2, hcounter->GetBinContent(2)+1);
}

// ------------ method called once each job just before starting event loop  ------------
void
TTHNtupleAnalyzer::beginJob()
{
}

// ------------ method called once each job just after ending the event loop  ------------
void
TTHNtupleAnalyzer::endJob()
{
}

// ------------ method called when starting to processes a run  ------------
/*
void
TTHNtupleAnalyzer::beginRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a run  ------------
/*
void
TTHNtupleAnalyzer::endRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when starting to processes a luminosity block  ------------
/*
void
TTHNtupleAnalyzer::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a luminosity block  ------------
/*
void
TTHNtupleAnalyzer::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
TTHNtupleAnalyzer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
	//The following says we do not know what parameters are allowed so do no validation
	// Please change this to state exactly what you do use, even if it is no parameters
	edm::ParameterSetDescription desc;
	desc.setUnknown();
	descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(TTHNtupleAnalyzer);
