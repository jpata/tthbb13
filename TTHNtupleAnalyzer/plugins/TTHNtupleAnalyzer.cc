// -*- C++ -*-
//
// Package:	TTH/TTHNtupleAnalyzer
// Class:	  TTHNtupleAnalyzer
//
/**\class TTHNtupleAnalyzer TTHNtupleAnalyzer.cc TTH/TTHNtupleAnalyzer/plugins/TTHNtupleAnalyzer.cc

 Description: A simple N-tuplizer for TTH(->bb), mapping the EDM miniAOD format to a "simple flat ROOT TTree"

 Implementation:
	Based on https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
	The base event is described by TTHTree, implemented in tth_tree.hh (autogenerated by tree_header.jl based on a specification)

	Tests for this module are in test/runtests.sh

	Helpful links:
		https://github.com/CJLST/ZZAnalysis/wiki/miniAOD-twiki
		https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookMiniAOD
*/
//
// Original Author:  Joosep Pata
//		 Created:  Tue, 15 Jul 2014 10:06:28 GMT
//
//


// system include files
#include <memory>
#include <algorithm>
#include <vector>
#include <string>
#include <iterator>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "DataFormats/Common/interface/ValueMap.h"
#include "DataFormats/BTauReco/interface/JetTag.h"

#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/JetReco/interface/GenJet.h"

#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"

#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/PackedCandidate.h"

//for top taggers
#include "DataFormats/BTauReco/interface/CATopJetTagInfo.h"
#include "DataFormats/JetReco/interface/HTTTopJetTagInfo.h"

#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"
#include "SimDataFormats/GeneratorProducts/interface/LHEEventProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/GenEventInfoProduct.h"

//#include "CommonTools/UtilAlgos/interface/PhysObjectMatcher.h"
//#include "CommonTools/UtilAlgos/interface/MatchByDRDPt.h"
//#include "CommonTools/UtilAlgos/interface/MatchLessByDPt.h"
//#include "CommonTools/UtilAlgos/interface/MCMatchSelector.h"
#include <EgammaAnalysis/ElectronTools/interface/ElectronEffectiveArea.h>

#include "FWCore/Common/interface/TriggerNames.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h"
#include "DataFormats/PatCandidates/interface/PackedTriggerPrescales.h"

#include "FWCore/Framework/interface/ESHandle.h"
#include "CondFormats/JetMETObjects/interface/JetCorrectorParameters.h"
#include "JetMETCorrections/Objects/interface/JetCorrectionsRecord.h"
#include "CondFormats/JetMETObjects/interface/JetCorrectionUncertainty.h"
#include "JetMETCorrections/Objects/interface/JetCorrector.h"

#include "TTH/TTHNtupleAnalyzer/interface/tth_tree.hh"
#include "TTH/TTHNtupleAnalyzer/interface/gen_association.h"

#include "TStopwatch.h"

#include "TLorentzVector.h"
#include "TString.h"

#include <Math/VectorUtil.h>

#include "TTH/TTHNtupleAnalyzer/interface/helpers.h"

//TTH, EventHypothesis
#include "TTH/TTHNtupleAnalyzer/interface/EventHypothesis.hh"

//converts a vector of objects to a vector of pointers 
template <typename T, typename R>
std::vector<R> to_ptrvec(T coll) {
	std::vector<R> ret;
	for (auto e : coll) {
		assert(&e != NULL);
		ret.push_back((R)&e);
	}
	return ret;
}

//ordering function for pt sorting
template <typename T>
bool order_by_pt(T a, T b) {
	assert(a!=NULL && b!=NULL);
	return (a->pt() > b->pt());
};


// Return a pointer interface for all objects (reference or pointer)
// From:
// http://stackoverflow.com/questions/14466620/c-template-specialization-calling-methods-on-types-that-could-be-pointers-or/14466705
template<typename T>
T * ptr(T & obj) { return &obj; } //turn reference into pointer!
template<typename T>
T * ptr(T * obj) { return obj; } //obj is already pointer, return it!


// OBSOLOTE: Not needed at the moment!
// Functor so we can sort a list of ElementType objects according to
// their deltaR distance to the reference object.  
// Can take anything that inherits the p4() to give Lorentz Vector. 
// Can deal with references and pointers.
template <typename ReferenceType, typename ElementType>
struct distance_sorter
{  
  ReferenceType reference;
  distance_sorter(ReferenceType reference) : reference(reference) { }
  bool operator()(ElementType first, 
		  ElementType second){    
    return ROOT::Math::VectorUtil::DeltaR( ptr(first)->p4(), ptr(reference)->p4()) < ROOT::Math::VectorUtil::DeltaR( ptr(second)->p4(), ptr(reference)->p4());
  }
};


template <typename JetType>
void fill_truth_matching(TTHTree* tthtree, 				 
			 JetType x, // object for which to fill - fatjet or HTT cand
			 int n, // position at which to insert new values in the tree (ie n_fat_jet)
			 const vector<const reco::Candidate*>  & truth_particles, // particles for matching
			 std::string prefix, // prefix for branch names
			 std::string truth_name // what are we matching (to select branch name to fill into) hadtop/parton/..
			 ){

  // Branch names to fill
  std::string name_pt_branch = prefix + "close_";
  name_pt_branch += truth_name;
  name_pt_branch += "_pt";

  std::string name_dr_branch = prefix + "close_";
  name_dr_branch += truth_name;
  name_dr_branch += "_dr";

  std::string name_i_branch = prefix + "close_";
  name_i_branch += truth_name;
  name_i_branch += "_i";

  // Calculate the DeltaR from each truth particle to the jet
  std::vector<double> distances;
  for (vector<const reco::Candidate*>::const_iterator it = truth_particles.begin();
       it != truth_particles.end();
       ++it){
    distances.push_back(ROOT::Math::VectorUtil::DeltaR(ptr(*it)->p4(), ptr(x)->p4()));
  }   
  
  // And find the index of the closest one
 std::vector<double>::iterator min_distance = std::min_element(std::begin(distances), std::end(distances));
 int index_closest = std::distance(std::begin(distances), min_distance);
 
  // Fill true pT and DeltaR if at least one truth object
  if (truth_particles.size() > 0){		
    tthtree->get_address<float *>(name_pt_branch)[n] = truth_particles[index_closest]->pt();
    tthtree->get_address<float *>(name_dr_branch)[n] = *min_distance;
    tthtree->get_address<int *>(  name_i_branch)[n]  = index_closest;
  }
  // Otherwise use dummy values
  else{
    tthtree->get_address<float *>(name_pt_branch)[n] = DEF_VAL_FLOAT;
    tthtree->get_address<float *>(name_dr_branch)[n] = 9999.0;
    tthtree->get_address<int *>(  name_i_branch)[n]  = DEF_VAL_INT;
  }

}//fill_truth_matching


// Function to fill the branches for a fatjet collection
// This needs to be templated as we can have either PFJets or BasicJet 
// objects as fatjets
template <typename JetType, typename CollectionType>
void fill_fatjet_branches(const edm::Event& iEvent, 
			  TTHTree* tthtree, 
			  std::string fj_object_name,
			  std::string fj_nsubs_name,
			  std::string fj_sds_name,
			  std::string fj_btags_name,
			  std::string fj_qvols_name,
			  std::string fj_branches_name,
			  // true top and anti top for optional matching
			  const vector<const reco::Candidate*>  & true_t,
			  // hard partons for matching
			  const vector<const reco::Candidate*>  & hard_partons,
			  // true higgs for matching
			  const vector<const reco::Candidate*>  & gen_higgs,
			  bool fj_usesubjets
			  ){
  
  // Get Fatjet iteself  
  
  edm::Handle<CollectionType>  fatjets;
  

  
  if (fj_usesubjets)
    iEvent.getByLabel(fj_object_name, "SubJets", fatjets);
  else
    iEvent.getByLabel(fj_object_name, fatjets);



  // Handles to get the Nsubjettiness
  edm::Handle<edm::ValueMap<float> > fatjet_nsub_tau1;
  edm::Handle<edm::ValueMap<float> > fatjet_nsub_tau2;
  edm::Handle<edm::ValueMap<float> > fatjet_nsub_tau3;
  if (fj_nsubs_name != "None"){
    iEvent.getByLabel(fj_nsubs_name, "tau1", fatjet_nsub_tau1);
    iEvent.getByLabel(fj_nsubs_name, "tau2", fatjet_nsub_tau2);
    iEvent.getByLabel(fj_nsubs_name, "tau3", fatjet_nsub_tau3);

    // Make sure the fatjets and nsujettiness containers have same size
    assert(fatjets->size()==fatjet_nsub_tau1->size());
    assert(fatjets->size()==fatjet_nsub_tau2->size());
    assert(fatjets->size()==fatjet_nsub_tau3->size());  
  }


  // Handle to get the Shower Deconstruction info
  edm::Handle<edm::ValueMap<double> > fatjet_sd_chi1;
  edm::Handle<edm::ValueMap<int> > fatjet_sd_nmj1;
  edm::Handle<edm::ValueMap<double> > fatjet_sd_chi2;
  edm::Handle<edm::ValueMap<int> > fatjet_sd_nmj2;
  edm::Handle<edm::ValueMap<double> > fatjet_sd_chi3;
  edm::Handle<edm::ValueMap<int> > fatjet_sd_nmj3;
  if (fj_sds_name != "None"){


    iEvent.getByLabel(fj_sds_name + "1", "chi", fatjet_sd_chi1);
    iEvent.getByLabel(fj_sds_name + "1", "nmicrojets", fatjet_sd_nmj1);

    iEvent.getByLabel(fj_sds_name + "2", "chi", fatjet_sd_chi2);
    iEvent.getByLabel(fj_sds_name + "2", "nmicrojets", fatjet_sd_nmj2);

    iEvent.getByLabel(fj_sds_name + "3", "chi", fatjet_sd_chi3);
    iEvent.getByLabel(fj_sds_name + "3", "nmicrojets", fatjet_sd_nmj3);


  }

  // b-tag discriminators handle
  edm::Handle<reco::JetTagCollection> btagDiscriminators;
  if (fj_btags_name != "None"){
    iEvent.getByLabel(fj_btags_name, btagDiscriminators);
    
    //std::cout << fatjets->size() << "  " << btagDiscriminators->size() << std::endl;

  }

  // Q-jet volatility handle
  edm::Handle<edm::ValueMap<float> > QjetVols;
  if (fj_qvols_name != "None")
    iEvent.getByLabel(fj_qvols_name,"QjetsVolatility", QjetVols);
	  


  // Loop over fatjets
  for (unsigned n_fat_jet = 0; n_fat_jet != fatjets->size(); n_fat_jet++){
	    
    const JetType& x = (*fatjets).at(n_fat_jet);
    
    LogDebug("fat jets") << "n_fat_jet=" << n_fat_jet << CANDPRINT(x);
	    	    
    std::string prefix("jet_");
    prefix.append(fj_branches_name);
    prefix.append("__");

    // Turn the branch address into the actual object we want to fill
    tthtree->get_address<float *>(prefix + "pt"  )[n_fat_jet] = x.pt();
    tthtree->get_address<float *>(prefix + "eta" )[n_fat_jet] = x.eta();
    tthtree->get_address<float *>(prefix + "phi" )[n_fat_jet] = x.phi();
    tthtree->get_address<float *>(prefix + "mass")[n_fat_jet] = x.mass();
    
    // Constituents
    tthtree->get_address<int *>(prefix + "nconst")[n_fat_jet] = x.getJetConstituents().size();
    tthtree->get_address<int *>(prefix + "ncharged")[n_fat_jet] = x.chargedMultiplicity();
    tthtree->get_address<int *>(prefix + "nneutral")[n_fat_jet] = x.neutralMultiplicity();


    // NSubjettiness
    if (fj_nsubs_name != "None"){
      tthtree->get_address<float *>(prefix + "tau1")[n_fat_jet] = fatjet_nsub_tau1->get(n_fat_jet);
      tthtree->get_address<float *>(prefix + "tau2")[n_fat_jet] = fatjet_nsub_tau2->get(n_fat_jet);
      tthtree->get_address<float *>(prefix + "tau3")[n_fat_jet] = fatjet_nsub_tau3->get(n_fat_jet);
    }     

    // Shower Deconstruction
    if (fj_sds_name != "None"){
      tthtree->get_address<float *>(prefix + "chi1")[n_fat_jet] = fatjet_sd_chi1->get(n_fat_jet);
      tthtree->get_address<int *>(prefix   + "nmj1")[n_fat_jet] = fatjet_sd_nmj1->get(n_fat_jet);

      tthtree->get_address<float *>(prefix + "chi2")[n_fat_jet] = fatjet_sd_chi2->get(n_fat_jet);
      tthtree->get_address<int *>(prefix   + "nmj2")[n_fat_jet] = fatjet_sd_nmj2->get(n_fat_jet);

      tthtree->get_address<float *>(prefix + "chi3")[n_fat_jet] = fatjet_sd_chi3->get(n_fat_jet);
      tthtree->get_address<int *>(prefix   + "nmj3")[n_fat_jet] = fatjet_sd_nmj3->get(n_fat_jet);
    }

    // B-tag
    if (fj_btags_name != "None"){
      tthtree->get_address<float *>(prefix + "btag")[n_fat_jet] = (*btagDiscriminators)[n_fat_jet].second;
    }

    // Q-jet volatility
    if (fj_qvols_name != "None")
      tthtree->get_address<float *>(prefix + "qvol")[n_fat_jet] = QjetVols->get(n_fat_jet);
   
    // Optional: Fill truth matching information
    if (ADD_TRUE_TOP_MATCHING_FOR_FJ)
      fill_truth_matching<JetType>(tthtree, x, n_fat_jet, true_t, prefix, "hadtop");
    if (ADD_TRUE_PARTON_MATCHING_FOR_FJ)	      
      fill_truth_matching<JetType>(tthtree, x, n_fat_jet, hard_partons, prefix, "parton");
    if (ADD_TRUE_HIGGS_MATCHING_FOR_FJ)	      
      fill_truth_matching<JetType>(tthtree, x, n_fat_jet, gen_higgs, prefix, "higgs");
        
  }// End loop over fatjets
  
  // Also count the number of fatjets
  std::string njet_branch("n__jet_" + fj_branches_name);
  *(tthtree->get_address<int *>(njet_branch)) = fatjets->size();  
}


// Function to fill the branches for a  truth collection
// (higgs, hadronic tops or partons)
// objects as fatjets
void fill_genparticle_branches(TTHTree* tthtree, 
			       const vector<const reco::Candidate*>  & particles,
			       std::string name){
  
  // Loop over particles
  for (vector<const reco::Candidate*>::const_iterator it = particles.begin();
       it != particles.end();
       ++it){
    
    std::string prefix("gen_");
    prefix.append(name);
    prefix.append("__");

    int n = it - particles.begin();
    
    // Fill the branches
    tthtree->get_address<float *>(prefix + "pt"  )[n]  = (*it)->pt();
    tthtree->get_address<float *>(prefix + "eta" )[n]  = (*it)->eta();
    tthtree->get_address<float *>(prefix + "phi" )[n]  = (*it)->phi();
    tthtree->get_address<float *>(prefix + "mass")[n]  = (*it)->mass();    
    tthtree->get_address<int   *>(prefix + "pdgid")[n] = (*it)->pdgId();    
    
  }
  
  // Also count the number of particles
  std::string n_branch("n__gen_" + name);
  *(tthtree->get_address<int *>(n_branch)) = particles.size();
}



//finds a matched genparticle by dR, dPt and id
//x - particle to match
//pruned - collection of genparticles
//returns: pointer to matched particle or 0 in case of no match
//in case of multiple matches, the one with smallest dR is returned
const reco::GenParticle* find_dr_dp_id_match(const reco::Candidate& x, edm::Handle<edm::View<reco::GenParticle>> pruned) {
	std::vector<const reco::GenParticle*> matched;
	for (auto& p : *pruned) {
		const float dr = sqrt(reco::deltaR2(x.p4(), p.p4()));
		const float rel_dp = fabs(x.pt()-p.pt())/p.pt();
		//LogDebug("jets") << "dR=" << dr << " rel_dp=" << rel_dp;
		if (dr<GENLEPTON_DR && rel_dp<GENLEPTON_REL_DP && x.pdgId()==p.pdgId()) {
			matched.push_back(&p);
		}
	}
	LogDebug("find_dr_dp_id_match") << "dR < " << GENLEPTON_DR << " matched " << matched.size();

	//sort genparticles by dR(recojet, genparticle) ascending
	auto sortf = [&x](const reco::GenParticle* a, const reco::GenParticle* b) -> bool {
		return (reco::deltaR2(x.p4(), a->p4()) < reco::deltaR2(x.p4(), b->p4()));
	};

	std::sort(matched.begin(), matched.end(), sortf);
	//if we had at least one match, choose lowest dR
	if (matched.size()>0) {
		LogDebug("find_dr_dp_id_match") << "best match " << PCANDPRINT(matched[0]);
		return matched[0];
	} else {
		return (const reco::GenParticle*)NULL;
	}
}

//Trigger lepton struct
typedef struct {
	float pt;
	float eta;
	float phi;
	int isL3;
	int isLF;
	//int index;
	void fill(float pt_ = -99, float eta_ = -99, float phi_ = -99,
				int isL3_ = -99, int isLF_ = -99 /*, int index_ = -99*/) {
		pt		= pt_ ;
		eta		= eta_;
		phi		= phi_;
		isL3	= isL3_;
		isLF	= isLF_;
		//index = index_;
	};
} LightTriggerObj ;

class TTHNtupleAnalyzer : public edm::EDAnalyzer {

public:
	explicit TTHNtupleAnalyzer(const edm::ParameterSet&);
	~TTHNtupleAnalyzer();

	static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


private:
	virtual void beginJob() override;
	virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
	virtual void endJob() override;
	virtual void finalizeLoop();

	// collection of muons, electrons, taus, jets
	const edm::EDGetTokenT<pat::MuonCollection> muonToken_;
	const edm::EDGetTokenT<pat::ElectronCollection> electronToken_;
	const edm::EDGetTokenT<pat::TauCollection> tauToken_;
	const edm::EDGetTokenT<pat::JetCollection> jetToken_;
	const edm::EDGetTokenT<std::vector<reco::GenJet>> genJetToken_;

	// collection of vertices
	const edm::EDGetTokenT<reco::VertexCollection> vertexToken_;

	// collection of gen particles
	const edm::EDGetTokenT<edm::View<reco::GenParticle> > prunedGenToken_;
	const edm::EDGetTokenT<edm::View<pat::PackedGenParticle> > packedGenToken_;

	// collection of  MET
	const edm::EDGetTokenT<pat::METCollection> metToken_;

        // fatjet information
        // objects = name of the jet collection
        // nsubs = name of the N-subjettiness calculation process
        // sds = name of the Shower Deconstruction calculation process (or None)
        // btags = name of the btagger processes (or None) 
        // qvols = name of the QJet volatility processes (or None) 
        // fatjet branches = name of the branches to put this in
        // usesubjets = either use that jet object or the "SubJets" field
        // !!the lists have to be in sync!!
	const std::vector<std::string> fatjet_objects_;
	const std::vector<std::string> fatjet_nsubs_;
	const std::vector<std::string> fatjet_sds_;
	const std::vector<std::string> fatjet_btags_;
	const std::vector<std::string> fatjet_qvols_;
	const std::vector<std::string> fatjet_branches_;
	const std::vector<int> fatjet_usesubjets_;

        // HEPTopTagger information
        // objects = name of the input collection
        // htt branches = name of the branches to put this in
        // !!the lists have to be in sync!!
	const std::vector<std::string> htt_objects_;
	const std::vector<std::string> htt_branches_;

        // CMSTopTagger information
        // objects = name of the input jet collection
        // infos = name of the input info collection
        // cmstt branches = name of the branches to put this in
        // !!the lists have to be in sync!!
	const std::vector<std::string> cmstt_objects_;
	const std::vector<std::string> cmstt_infos_;
	const std::vector<std::string> cmstt_branches_;
	const std::vector<std::string> cmstt_btags_;
	
	// LHE event product (may not be present!!)
	const edm::EDGetTokenT<LHEEventProduct> lheToken_;

	// the output tree
	TTHTree* tthtree;
	TNamed* config_dump;
	const edm::Service<TFileService> fs;

	//a histogram with event counts	
	TH1D* hcounter;

	// a watch for CPU monitoring
	TStopwatch* sw;

	//const ElectronEffectiveArea::ElectronEffectiveAreaType electron_eff_area_type = ElectronEffectiveArea::ElectronEffectiveAreaType::kEleGammaAndNeutralHadronIso03;
	//const ElectronEffectiveArea::ElectronEffectiveAreaType electron_eff_area_target = ElectronEffectiveArea::ElectronEffectiveAreaTarget::kEleEAData2012;

	// particle identifiers
	const std::vector<std::string> tauIdentifiers_;
	const std::vector<std::string> eleIdentifiers_;

	// trigger paths to be checked
	const std::vector<std::string> triggerIdentifiers_;
	const std::vector<std::string> triggerIdentifiersForMatching_;

	// trigger results
	const edm::EDGetTokenT<edm::TriggerResults> triggerBits_;
	const edm::EDGetTokenT<pat::TriggerObjectStandAloneCollection> triggerObjects_;
	const edm::EDGetTokenT<pat::PackedTriggerPrescales> triggerPrescales_;

	// parameters
	const bool		isMC_;
	const double	jetPt_min_;
	const int		jetMult_min_;
	const double	muPt_min_;
	const double	elePt_min_;
	const double	tauPt_min_;
  	const double	genPartonPt_min_;
        const int       genPartonStatus_;

	JetCorrectorParameters* jetCorrPars;
	JetCorrectionUncertainty* jetCorrUnc;
	const edm::EDGetTokenT<double> rhoSrc_;

};


TTHNtupleAnalyzer::TTHNtupleAnalyzer(const edm::ParameterSet& iConfig) :
	muonToken_(consumes<pat::MuonCollection>(iConfig.getParameter<edm::InputTag>("muons"))),
	electronToken_(consumes<pat::ElectronCollection>(iConfig.getParameter<edm::InputTag>("electrons"))),
	tauToken_(consumes<pat::TauCollection>(iConfig.getParameter<edm::InputTag>("taus"))),
	jetToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("jets"))),
	genJetToken_(consumes<std::vector<reco::GenJet>>(iConfig.getParameter<edm::InputTag>("genjets"))),

	vertexToken_(consumes<reco::VertexCollection>(iConfig.getParameter<edm::InputTag>("vertices"))),
	prunedGenToken_(consumes<edm::View<reco::GenParticle> >(iConfig.getParameter<edm::InputTag>("pruned"))),
	packedGenToken_(consumes<edm::View<pat::PackedGenParticle> >(iConfig.getParameter<edm::InputTag>("packed"))),
	metToken_(consumes<pat::METCollection>(iConfig.getParameter<edm::InputTag>("mets"))),
	       					  
        fatjet_objects_(iConfig.getParameter<std::vector<std::string>>("fatjetsObjects")),
        fatjet_nsubs_(iConfig.getParameter<std::vector<std::string>>("fatjetsNsubs")),
        fatjet_sds_(iConfig.getParameter<std::vector<std::string>>("fatjetsSDs")),
        fatjet_btags_(iConfig.getParameter<std::vector<std::string>>("fatjetsBtags")),
        fatjet_qvols_(iConfig.getParameter<std::vector<std::string>>("fatjetsQvols")),
        fatjet_branches_(iConfig.getParameter<std::vector<std::string>>("fatjetsBranches")),
        fatjet_usesubjets_(iConfig.getParameter<std::vector<int>>("fatjetsUsesubjets")),

        htt_objects_(iConfig.getParameter<std::vector<std::string>>("httObjects")),
        htt_branches_(iConfig.getParameter<std::vector<std::string>>("httBranches")),

        cmstt_objects_(iConfig.getParameter<std::vector<std::string>>("cmsttObjects")),
        cmstt_infos_(iConfig.getParameter<std::vector<std::string>>("cmsttInfos")),
        cmstt_branches_(iConfig.getParameter<std::vector<std::string>>("cmsttBranches")),
        cmstt_btags_(iConfig.getParameter<std::vector<std::string>>("cmsttBtags")),
							  
	//Gen-level
	lheToken_( (iConfig.getParameter<edm::InputTag>("lhe")).label()!="" ?
			consumes<LHEEventProduct>( iConfig.getParameter<edm::InputTag>("lhe")) : edm::EDGetTokenT<LHEEventProduct>() ),


	//output
	tthtree(new TTHTree(fs->make<TTree>("events", "events"))),
	config_dump(fs->make<TNamed>("configdump", iConfig.dump().c_str())),
	hcounter(fs->make<TH1D>("event_counter", "event_counter", 5, 0, 5)),

	//ID lists for tau and ele
	tauIdentifiers_(iConfig.getParameter<std::vector<std::string>>("tauIdentifiers")),
	eleIdentifiers_(iConfig.getParameter<std::vector<std::string>>("eleIdentifiers")),

	//triggers
	triggerIdentifiers_(iConfig.getParameter<std::vector<std::string>>("triggerIdentifiers")),
	triggerIdentifiersForMatching_(iConfig.getParameter<std::vector<std::string>>("triggerIdentifiersForMatching")),
	triggerBits_(consumes<edm::TriggerResults>(iConfig.getParameter<edm::InputTag>("bits"))),
	triggerObjects_(consumes<pat::TriggerObjectStandAloneCollection>(iConfig.getParameter<edm::InputTag>("objects"))),
	triggerPrescales_(consumes<pat::PackedTriggerPrescales>(iConfig.getParameter<edm::InputTag>("prescales"))),
	
	//cuts
	isMC_(iConfig.getParameter<bool>("isMC")),
	jetPt_min_ (iConfig.getUntrackedParameter<double>("jetPt_min", 5.)),
	jetMult_min_(iConfig.getUntrackedParameter<int> ("jetMult_min", DEF_VAL_INT)),
	muPt_min_ (iConfig.getUntrackedParameter<double>("muPt_min", 5.)),
	elePt_min_ (iConfig.getUntrackedParameter<double>("elePt_min", 5.)),
	tauPt_min_ (iConfig.getUntrackedParameter<double>("tauPt_min", 5.)),
	genPartonPt_min_(iConfig.getUntrackedParameter<double>("genPartonPt_min", 200.)),
        genPartonStatus_(iConfig.getUntrackedParameter<int>("genPartonStatus", 23)),

	jetCorrPars(new JetCorrectorParameters(iConfig.getParameter<edm::FileInPath>("jecFile").fullPath().c_str(), "Total")),
	jetCorrUnc(new JetCorrectionUncertainty(*jetCorrPars)),
	rhoSrc_(consumes<double>(iConfig.getParameter<edm::InputTag>("rho")))
{
	tthtree->make_branches();
	
	hcounter->GetXaxis()->SetBinLabel(1, "TTHNtupleAnalyzer__processed");
	hcounter->GetXaxis()->SetBinLabel(2, "TTHNtupleAnalyzer__passed");

	sw = new TStopwatch();
}


TTHNtupleAnalyzer::~TTHNtupleAnalyzer()
{
	delete sw;
}

void TTHNtupleAnalyzer::finalizeLoop() {
}

// ------------ method called for each event ------------
void
TTHNtupleAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
	//fill analyzed
	hcounter->SetBinContent(1, hcounter->GetBinContent(1)+1);
	using namespace edm;

	sw->Start();
	tthtree->loop_initialize();

	tthtree->event__id = (unsigned int)iEvent.id().event();
	tthtree->event__run = (unsigned int)iEvent.id().run();
	tthtree->event__lumi = (unsigned int)iEvent.id().luminosityBlock();

	//Primary vertices
	edm::Handle<reco::VertexCollection> vertices;
	iEvent.getByToken(vertexToken_, vertices);
	if (vertices->empty()) {
		edm::LogError("loop") << "no vertices found";
		finalizeLoop();
		return;
	}
	const reco::Vertex &PV = vertices->front();
	tthtree->n__pv = vertices->size();

	if (isMC_) {
	
	// MC Event Weight
	edm::Handle<GenEventInfoProduct> genEvtInfo;
	iEvent.getByLabel( "generator", genEvtInfo );
	tthtree->weight__genmc = genEvtInfo->weight();
	 
	Handle<edm::View<reco::GenParticle> > pruned;
	
	//Pileup and genparticles
		Handle<std::vector<PileupSummaryInfo>> PupInfo;
		iEvent.getByLabel(edm::InputTag("addPileupInfo"), PupInfo);
		std::vector<PileupSummaryInfo>::const_iterator PVI;
		tthtree->n__pvi = PupInfo->size();
		int n_pu = 0;
		for (PVI = PupInfo->begin(); PVI != PupInfo->end(); ++PVI)
		{
			const int BX = PVI->getBunchCrossing();
			LogDebug("PVI") << n_pu << " BX=" << BX;
			tthtree->pvi__n0[n_pu] = PVI->getPU_NumInteractions();
			tthtree->pvi__bx[n_pu] = BX;
			if (BX == 0)
			{
				tthtree->pvi__ntrue[n_pu] = PVI->getTrueNumInteractions();
			}
			n_pu += 1;
		}
	}

	// Sanity check the fatjet lists-of-names
	assert(fatjet_objects_.size()==fatjet_nsubs_.size());
	assert(fatjet_objects_.size()==fatjet_sds_.size());
	assert(fatjet_objects_.size()==fatjet_btags_.size());
	assert(fatjet_objects_.size()==fatjet_qvols_.size());
	assert(fatjet_objects_.size()==fatjet_branches_.size());
	assert(fatjet_objects_.size()==fatjet_usesubjets_.size());

	// Sanity check the htt lists-of-names
	assert(htt_objects_.size()==htt_branches_.size());

	// Sanity check the cmstt lists-of-names
	assert(cmstt_objects_.size()==cmstt_branches_.size());
	assert(cmstt_objects_.size()==cmstt_infos_.size());
	assert(cmstt_objects_.size()==cmstt_btags_.size());
	       
	edm::Handle<edm::TriggerResults> triggerBits;
	edm::Handle<pat::TriggerObjectStandAloneCollection> triggerObjects;
	edm::Handle<pat::PackedTriggerPrescales> triggerPrescales; 

	iEvent.getByToken(triggerBits_, triggerBits);
	iEvent.getByToken(triggerObjects_, triggerObjects);
	iEvent.getByToken(triggerPrescales_, triggerPrescales);


	const edm::TriggerNames &names = iEvent.triggerNames(*triggerBits);
	//std::cout << "\n === TRIGGER PATHS === " << std::endl;

	//trigger identifiers
	int n__tr = 0;
	
	Handle<edm::View<reco::GenParticle> > pruned;
	if (isMC_) {
		iEvent.getByToken(prunedGenToken_,pruned);
	}
	
	edm::Handle<double> rhoHandle;
	iEvent.getByToken(rhoSrc_, rhoHandle);
	const double rho = *rhoHandle;

	for (unsigned int j = 0; j < triggerIdentifiers_.size(); ++j) {

		string idName = triggerIdentifiers_[j];
		string idNameUnstarred = idName;
		bool isStarred = (idName.find("*")!=string::npos);
		if( isStarred ) idNameUnstarred.erase( idName.find("*"), 1 );

		for (unsigned int i = 0, n = triggerBits->size(); i < n; ++i) {

			if( (isStarred && names.triggerName(i).find(idNameUnstarred)!=string::npos ) ||
					(!isStarred && names.triggerName(i)==idName)
			) {
				tthtree->trigger__bits	[n__tr] = triggerBits->accept(i);
				tthtree->trigger__prescale[n__tr] = triggerPrescales->getPrescaleForIndex(i);
			}
			LogDebug("trigger") << "Trigger " << names.triggerName(i) <<
			", prescale " << triggerPrescales->getPrescaleForIndex(i) <<
			": " << (triggerBits->accept(i) ? "PASS" : "fail (or not run)") << std::endl;
			LogDebug("trigger") << "'" << names.triggerName(i) << "'," << std::endl;
		}
		n__tr++;
	}
	tthtree->n__tr = n__tr;

	if( int(triggerIdentifiers_.size())>=T_MAX ) {
		edm::LogError("T_MAX") << "Exceeded vector T_MAX with n__tr: " << n__tr << ">=> " << T_MAX;
		throw std::exception();
	}

	/////////////////////////////////////////////
	//std::cout << "\n === TRIGGER OBJECTS === " << std::endl;
	vector< LightTriggerObj > muTriggerObj;
	vector< LightTriggerObj > eleTriggerObj;
	vector< LightTriggerObj > jetTriggerObj;

	int countObj = 0;
	for (pat::TriggerObjectStandAlone obj : *triggerObjects) { // note: not "const &" since we want to call unpackPathNames
		//LogDebug("triggers") << "triggerObject loop";

		//unpackPathNames crashes
		obj.unpackPathNames(names);
		//LogDebug("triggers") << "unpacked names";
		unsigned filterSize = obj.filterIds().size();
		//LogDebug("triggers") << "filterSize" << filterSize;
		if( filterSize!=1 ) continue;

		LightTriggerObj lightObj;
		const auto fids = obj.filterIds();
		
		const bool is_jet = (find(fids.begin(), fids.end(), 85) != fids.end() ||
			find(fids.begin(), fids.end(), 86) != fids.end() ||
			find(fids.begin(), fids.end(), -84) != fids.end() ||
			find(fids.begin(), fids.end(), -89) != fids.end()
		);
		const bool is_ele = (fids[0] == 82);
		const bool is_mu = (fids[0] == 83);
		
		stringstream ss1;
		for (auto f : fids)
			ss1 << f << " ";
		LogDebug("trigger") << "fids " << ss1.str();
		
		// all path names associated to this obj
		std::vector<std::string> pathNamesAll = obj.pathNames(false);
		
		stringstream ss2;
		for (auto f : pathNamesAll)
			ss2 << f << " ";
		LogDebug("trigger") << "pathnames " << ss2.str();
		
		LogDebug("trigger") << "filterids " << is_mu << " " << is_ele << " " << is_jet;
	
		if( is_ele || is_mu || is_jet ) {

			bool isL3 = false;
			bool isLF = false;

			// loop over them
			for (unsigned h = 0, n = pathNamesAll.size(); h < n; ++h) {

				// loop over the trigger bits for which we require a match
				for (unsigned int j = 0; j < triggerIdentifiersForMatching_.size(); ++j) {
					// check whether we have starred names
					const string idName = triggerIdentifiersForMatching_[j];
					//LogDebug("triggers") << "identifier for matcing " << idName;
					string idNameUnstarred = idName;
					bool isStarred = idName.find("*") != string::npos;
					if( isStarred ) idNameUnstarred.erase( idName.find("*"), 1 );
					//cout << "checking " << pathNamesAll[h] << " " << idNameUnstarred << endl;

					// check whether this path matches
					if( ((isStarred && pathNamesAll[h].find(idNameUnstarred)!=string::npos) ||
							(!isStarred && pathNamesAll[h]==idName)
						) && (
							(is_ele && idNameUnstarred.find("Ele") != string::npos ) || //electron
							(is_mu && idNameUnstarred.find("Mu") != string::npos && obj.collection().find("L3") != string::npos ) || //muon
							(is_jet && idNameUnstarred.find("Jet") != string::npos) //jet
						)
					) {
						bool isL3tmp = obj.hasPathName( pathNamesAll[h], false, true );
						bool isLFtmp = obj.hasPathName( pathNamesAll[h], true, false );
						isL3 = isL3 || isL3tmp;
						isLF = isLF || (isLFtmp && isL3tmp);
						//cout << h << "th path for Obj "<< countObj << " with " << obj.filterIds()[0] << " with pt=" << obj.pt() << " matches to [" << j << "]"
						//	<< " " << isL3 << " " << isLF << endl;
					}

				}
			}

			if(isL3) {
				lightObj.fill( obj.pt(), obj.eta(), obj.phi(), isL3, isLF );
				if(is_ele)
					eleTriggerObj.push_back(lightObj);
				if(is_mu)
					muTriggerObj.push_back (lightObj);
				if(is_jet)
					jetTriggerObj.push_back(lightObj);
			}

		} // is Ele or muon
		countObj++;
	}

	for(unsigned int m = 0 ; m < eleTriggerObj.size(); m++){
	  LogDebug("triggerobj") << m << "th ele: pt=" << eleTriggerObj[m].pt << ", eta=" <<  eleTriggerObj[m].eta
	 << ", PASS trigger ["  << "]: " <<  eleTriggerObj[m].isL3 <<  eleTriggerObj[m].isLF;
	}
	for(unsigned int m = 0 ; m < muTriggerObj.size(); m++){
	  LogDebug("triggerobj") << m << "th mu: pt=" << muTriggerObj[m].pt << ", eta=" <<  muTriggerObj[m].eta
	 << ", PASS trigger [" << "]: " <<  muTriggerObj[m].isL3 <<  muTriggerObj[m].isLF;
	}
	for(unsigned int m = 0 ; m < jetTriggerObj.size(); m++){
	  LogDebug("triggerobj") << m << "th jet: pt=" << jetTriggerObj[m].pt << ", eta=" <<  jetTriggerObj[m].eta
	 << ", PASS trigger [" << "]: " <<  jetTriggerObj[m].isL3 <<  jetTriggerObj[m].isLF;
	}
	//////////////////////////////////////////////////////////

	edm::Handle<pat::MuonCollection> muons;
	iEvent.getByToken(muonToken_, muons);

	// lepton counters
	int n__lep = 0;
	int n__mu = 0;
	int n__ele = 0;
	int n__tau = 0;

	//collection to keep track of lepton pointers in the same order as in the tthtree->lep__* arrays
	vector<const reco::Candidate*> leptons;

	// jet counter
	int n__jet = 0;
	
	std::vector<const pat::Muon*> analysis_muons;
	for (const pat::Muon &x : *muons) {
		
		LogDebug("muons") << "n__mu=" << n__mu <<
						" pt=" << CANDPRINT(x) <<
						"abs eta " << TMath::Abs(x.eta()) << " " <<
						"isPF " << x.isPFMuon() << " " <<
						"isGlobal" << x.isGlobalMuon() << " " <<
						"normchi2" << (x.globalTrack().isNonnull() ? x.normChi2() : DEF_VAL_FLOAT) << " " << 
						"track layers " << (x.track().isNonnull() ? x.track()->hitPattern().trackerLayersWithMeasurement() : DEF_VAL_INT) << " " <<
						"globalTrack hits "<< (x.globalTrack().isNonnull() ? x.globalTrack()->hitPattern().numberOfValidMuonHits() : DEF_VAL_INT) << " " <<
						"dxy " << (x.muonBestTrack().isNonnull() ? x.muonBestTrack()->dxy(PV.position()) : DEF_VAL_INT) << " " <<
						"dz " << (x.muonBestTrack().isNonnull() ? x.muonBestTrack()->dz(PV.position()) : DEF_VAL_INT) << " " <<
						"inner pixelhits "<< (x.innerTrack().isNonnull() ? x.innerTrack()->hitPattern().numberOfValidPixelHits() : DEF_VAL_INT) << " " <<
						"stations " << x.numberOfMatchedStations() << " " <<
						"lID=" << is_loose_muon(x) << " " <<
						"tID=" << is_tight_muon(x, PV) << " " <<
						"rel_iso "<< dbc_rel_iso(x);

		if( x.pt()<muPt_min_ ) {
			LogDebug("muons") << "n__mu=" << n__mu << " fails pt cut" << endl;
			continue;
		}
		leptons.push_back((const reco::Candidate*)&x);

		float minDist = 999.;
		float minDpT = 999.;
		for(unsigned int m = 0 ; m < muTriggerObj.size(); m++) {
			LightTriggerObj obj = muTriggerObj[m];
			float dist = sqrt( (obj.eta-x.eta())*(obj.eta-x.eta()) + (obj.phi-x.phi())*(obj.phi-x.phi()) );
			float dpT = fabs( obj.pt - x.pt() )/x.pt();
			if( dist<minDist && dist<0.50 && dpT<minDpT && dpT<0.50 ) {
				tthtree->trig_lep__pt [n__lep] = obj.pt;
				tthtree->trig_lep__eta[n__lep] = obj.eta;
				tthtree->trig_lep__phi[n__lep] = obj.phi;
				tthtree->trig_lep__pass[n__lep]= obj.isLF + 1;
				minDist = dist;
				minDpT = dpT;
			}
		}
		if( minDist>998. ) {
			tthtree->trig_lep__pass[n__lep] = 0;
		}

		tthtree->lep__eta[n__lep] = x.eta();
		tthtree->lep__pt[n__lep] = x.pt();
		tthtree->lep__phi[n__lep] = x.phi();
		tthtree->lep__mass[n__lep] = x.mass();
		tthtree->lep__id[n__lep] = x.pdgId();
		tthtree->lep__type[n__lep] = abs(x.pdgId());
		tthtree->lep__charge[n__lep] = x.charge();

		tthtree->lep__is_tight_id[n__lep] = is_tight_muon(x, PV);
		tthtree->lep__is_tight[n__lep] = is_tight_muon(x, PV) && tight_muon_iso(x);
		tthtree->lep__is_loose[n__lep] = is_loose_muon(x);

		tthtree->lep__ch_iso[n__lep] = x.chargedHadronIso();
		tthtree->lep__puch_iso[n__lep] = x.puChargedHadronIso();
		tthtree->lep__ec_iso[n__lep] = x.ecalIso();
		tthtree->lep__hc_iso[n__lep] = x.hcalIso();
		tthtree->lep__p_iso[n__lep] = x.particleIso();
		tthtree->lep__ph_iso[n__lep] = x.photonIso();

		tthtree->lep__rel_iso[n__lep] = dbc_rel_iso(x);
		tthtree->lep__rel_iso2[n__lep] = rc_rel_iso(x, rho);

		if (x.muonBestTrack().isNonnull()) {
			tthtree->lep__dxy[n__lep] = x.muonBestTrack()->dxy(PV.position());
			tthtree->lep__dz[n__lep] = x.muonBestTrack()->dz(PV.position());
		} else {
			edm::LogWarning("muon") << "gsfTrack is 0 for n__mu=" << n__mu;
		}
		if (isMC_) {
			const reco::GenParticle* gp = x.genParticle();
			if (gp == NULL) {
				LogDebug("muon") << "n__lep=" << n__lep << " does not have genParticle(), doing dR/dP matching";
				gp = find_dr_dp_id_match(x, pruned);
			}
			if (x.genParticle() != NULL) {
				tthtree->gen_lep__eta[n__lep] = gp->eta();
				tthtree->gen_lep__pt[n__lep] = gp->pt();
				tthtree->gen_lep__phi[n__lep] = gp->phi();
				tthtree->gen_lep__mass[n__lep] = gp->mass();
				tthtree->gen_lep__id[n__lep] = gp->pdgId();
				tthtree->gen_lep__status[n__lep] = gp->status();
			} else {
				LogDebug("muons") << "genParticle()==0 for muon n__mu=" << n__mu;
			}
		}
		n__mu += 1;
		n__lep += 1;
		analysis_muons.push_back(&x);
	} //muons


	//Electrons
	edm::Handle<pat::ElectronCollection> electrons;
	iEvent.getByToken(electronToken_, electrons);
	std::vector<const pat::Electron*> analysis_electrons;
	for (const pat::Electron &x : *electrons) {
		LogDebug("electrons") << "n__ele=" << n__ele << CANDPRINT(x); 
		if( x.pt()<elePt_min_ ) {
			LogDebug("electrons") << "n__ele=" << n__ele << " fails pt cut" << endl;
			continue;
		}
		
		float minDist = 999.;
		float minDpT = 999.;
		for(unsigned int m = 0 ; m < eleTriggerObj.size(); m++) {
			LightTriggerObj obj = eleTriggerObj[m];
			float dist = sqrt( (obj.eta-x.eta())*(obj.eta-x.eta()) + (obj.phi-x.phi())*(obj.phi-x.phi()) );
			float dpT = fabs( obj.pt - x.pt() )/x.pt();
			if( dist<minDist && dist<0.50 && dpT<minDpT && dpT<0.50 ) {
				tthtree->trig_lep__pt [n__lep] = obj.pt;
				tthtree->trig_lep__eta[n__lep] = obj.eta;
				tthtree->trig_lep__phi[n__lep] = obj.phi;
				tthtree->trig_lep__pass[n__lep]= obj.isLF + 1;
				minDist = dist;
				minDpT = dpT;
			}
		}
		if( minDist>998. ) {
			tthtree->trig_lep__pass[n__lep] = 0;
		}
		leptons.push_back((const reco::Candidate*)&x);

		tthtree->lep__eta[n__lep] = x.eta();
		tthtree->lep__pt[n__lep] = x.pt();
		tthtree->lep__phi[n__lep] = x.phi();
		tthtree->lep__mass[n__lep] = x.mass();
		tthtree->lep__id[n__lep] = x.pdgId();
		tthtree->lep__charge[n__lep] = x.charge();

		tthtree->lep__ch_iso[n__lep] = x.chargedHadronIso();
		tthtree->lep__puch_iso[n__lep] = x.puChargedHadronIso();
		tthtree->lep__ec_iso[n__lep] = x.ecalIso();
		tthtree->lep__hc_iso[n__lep] = x.hcalIso();
		tthtree->lep__p_iso[n__lep] = x.particleIso();
		tthtree->lep__ph_iso[n__lep] = x.photonIso();

		tthtree->lep__rel_iso[n__lep] = dbc_rel_iso(x);
		tthtree->lep__rel_iso2[n__lep] = rc_rel_iso(x, rho);
		LogDebug("leptoniso") << dbc_rel_iso(x) << " " << x.userFloat("deltaBetaCorrRelIso") << " " << x.userFloat("rhoCorrRelIso");

		tthtree->lep__is_tight_id[n__lep] = is_tight_electron(x, PV);
		tthtree->lep__is_tight[n__lep] = is_tight_electron(x, PV) && tight_electron_iso(x);
		tthtree->lep__is_loose[n__lep] = is_loose_electron(x, PV);

		unsigned int ele_id_idx = 0;
		tthtree->lep__id_bitmask[n__lep] = 0;
		for (const auto& ele_id : eleIdentifiers_) {
			LogDebug("ele") << " n__lep=" << n__lep << " ID(" << ele_id << ")=" << x.electronID(ele_id);
			if (x.electronID(ele_id)) {
				//passes, flip bit with index tau_id_idx to ON
				tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] | (1 << ele_id_idx);
			} else {
				//fails, flip bit with index tau_id_idx to OFF
				tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] & ~(1 << ele_id_idx);
			}
			ele_id_idx += 1;
			if (ele_id_idx>= 32) {
				edm::LogWarning("ele") << "More electron ID-s specified than can fit in bitmask, truncating after " << ele_id;
				break;
			}
		}

		if (x.gsfTrack().isNonnull()) {
			tthtree->lep__dxy[n__lep] = x.gsfTrack()->dxy(PV.position());
			tthtree->lep__dz[n__lep] = x.gsfTrack()->dz(PV.position());
		} else {
			edm::LogWarning("electron") << "gsfTrack is 0 for n__ele=" << n__ele;
		}
		if (isMC_) {
			const reco::GenParticle* gp = x.genParticle();
			if (gp == NULL) {
				LogDebug("electron") << "n__lep=" << n__lep << " does not have genParticle(), doing dR/dP matching";
				gp = find_dr_dp_id_match(x, pruned);
			}
			if (gp != NULL) {
				tthtree->gen_lep__eta[n__lep] = gp->eta();
				tthtree->gen_lep__pt[n__lep] = gp->pt();
				tthtree->gen_lep__phi[n__lep] = gp->phi();
				tthtree->gen_lep__mass[n__lep] = gp->mass();
				tthtree->gen_lep__id[n__lep] = gp->pdgId();
				tthtree->gen_lep__status[n__lep] = gp->status();
			} else {
				LogDebug("electron") << "genParticle()==0 for electron n__ele=" << n__ele;
			}
		}
		n__ele += 1;
		n__lep += 1;

		analysis_electrons.push_back(&x);
	} // electrons

	edm::Handle<pat::TauCollection> taus;
	iEvent.getByToken(tauToken_, taus);
	std::vector<const pat::Tau*> analysis_taus;
	for (const pat::Tau &x : *taus) {
		LogDebug("taus") << "n__tau=" << n__tau <<
			" pt=" << CANDPRINT(x);
		
		if( x.pt()<tauPt_min_ ) {
			LogDebug("taus") << "n__tau=" << n__tau << " fails pt cut" << endl;
			continue;
		}

		leptons.push_back((const reco::Candidate*)&x);

		tthtree->lep__eta[n__lep] = x.eta();
		tthtree->lep__pt[n__lep] = x.pt();
		tthtree->lep__phi[n__lep] = x.phi();
		tthtree->lep__mass[n__lep] = x.mass();
		tthtree->lep__id[n__lep] = x.pdgId();
		tthtree->lep__charge[n__lep] = x.charge();

		tthtree->lep__ch_iso[n__lep] = x.chargedHadronIso();
		tthtree->lep__puch_iso[n__lep] = x.puChargedHadronIso();
		tthtree->lep__ec_iso[n__lep] = x.ecalIso();
		tthtree->lep__hc_iso[n__lep] = x.hcalIso();
		tthtree->lep__p_iso[n__lep] = x.particleIso();
		tthtree->lep__ph_iso[n__lep] = x.photonIso();
		
		tthtree->lep__is_tight[n__lep] = is_good_tau(x);
		tthtree->lep__is_loose[n__lep] = is_good_tau(x); //FIXME: implement loose tau ID

		//Bit-shift specified tau id-s into the id_bitmask
		//Order is specified in the python config
		//http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
		unsigned int tau_id_idx = 0;
		tthtree->lep__id_bitmask[n__lep] = 0;
		for (const auto& tau_id : tauIdentifiers_) {
			if (x.tauID(tau_id)) {
				//passes, flip bit with index tau_id_idx to ON
				tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] | (1 << tau_id_idx);
			} else {
				//fails, flip bit with index tau_id_idx to OFF
				tthtree->lep__id_bitmask[n__lep] = tthtree->lep__id_bitmask[n__lep] & ~(1 << tau_id_idx);
			}
			tau_id_idx += 1;
			if (tau_id_idx>= 32) {
				edm::LogWarning("tau") << "More tau ID-s specified than can fit in bitmask, truncating after " << tau_id;
				break;
			}
		}


		if (x.leadTrack().isNonnull()) {
			tthtree->lep__dxy[n__lep] = x.leadTrack()->dxy(PV.position());
			tthtree->lep__dz[n__lep] = x.leadTrack()->dz(PV.position());
		} else {
			LogDebug("tau") << "leadTrack is 0 for n__tau=" << n__tau;
		}

		const reco::GenParticle* gp = x.genParticle();
		if (isMC_) {
			if (gp == NULL) {
				LogDebug("tau") << "n__lep=" << n__lep << " does not have genParticle(), doing dR/dP matching";
				gp = find_dr_dp_id_match(x, pruned);
			}

			if (gp != NULL) {
				tthtree->gen_lep__eta[n__lep] = gp->eta();
				tthtree->gen_lep__pt[n__lep] = gp->pt();
				tthtree->gen_lep__phi[n__lep] = gp->phi();
				tthtree->gen_lep__mass[n__lep] = gp->mass();
				tthtree->gen_lep__id[n__lep] = gp->pdgId();
				tthtree->gen_lep__status[n__lep] = gp->status();
			} else {
				LogDebug("taus") << "genParticle()==0 for tau n__tau=" << n__tau;
			}
		}
		n__tau += 1;
		n__lep += 1;

		analysis_taus.push_back(&x);
	} // taus
	 

	edm::Handle<pat::JetCollection> jets;
	iEvent.getByToken(jetToken_, jets);

	//sort jets by pt
	//auto jetps = to_ptrvec<const std::vector<pat::Jet>&, const pat::Jet*>(*jets);
	//std::sort(jetps.begin(), jetps.end(), order_by_pt<const pat::Jet*>);

	//jet uncertainties
	//https://twiki.cern.ch/twiki/bin/view/CMSPublic/WorkBookJetEnergyCorrections

	std::vector<pat::Jet> analysis_jets;
	for (auto x : *jets) {
		//assert(_x != NULL);

		// jet pt cut
		if( x.pt()<jetPt_min_ ) {
			LogDebug("jets") << "n__jet=" << n__jet << " fails pt cut" << endl;
			continue;
		}

		// jet ID
		if( !jetID( x ) ) {
			LogDebug("jets") << "n__jet=" << n__jet << " fails ID cut" << endl;
			continue;
		}

		//dR overlap checking between loose leptons and jets
		bool fails_dr = false;
		for (int n = 0; n < n__lep; n++) {
			TLorentzVector v1;
			v1.SetPtEtaPhiM(
				tthtree->lep__pt[n],
				tthtree->lep__eta[n],
				tthtree->lep__phi[n],
				tthtree->lep__mass[n]
			);
			
			TLorentzVector v2;
			v2.SetPtEtaPhiM(
				x.pt(),
				x.eta(),
				x.phi(),
				x.mass()
			);

			double dr = v1.DeltaR(v2);
			if (tthtree->lep__is_loose[n]==1 && dr < JET_LEPTON_DR) {
				LogDebug("jet") << "dR failed" << CANDPRINT(x) << " lep " << tthtree->lep__pt[n] << " " << tthtree->lep__eta[n] << " " << tthtree->lep__phi[n] << " " << tthtree->lep__id[n];
				fails_dr = true;
				break;
			}
		}
		if (fails_dr) {
			continue;	
		}
		
		float minDist = 999.;
		float minDpT = 999.;
		for(unsigned int m = 0 ; m < jetTriggerObj.size(); m++) {
			LightTriggerObj& obj = jetTriggerObj[m];
			float dist = sqrt( (obj.eta-x.eta())*(obj.eta-x.eta()) + (obj.phi-x.phi())*(obj.phi-x.phi()) );
			float dpT = fabs( obj.pt - x.pt() )/x.pt();
			if( dist<minDist && dist<0.50 && dpT<minDpT && dpT<0.50 ) {
				tthtree->trig_jet__pt [n__jet] = obj.pt;
				tthtree->trig_jet__eta[n__jet] = obj.eta;
				tthtree->trig_jet__phi[n__jet] = obj.phi;
				tthtree->trig_jet__pass[n__jet]= obj.isLF + 1;
				minDist = dist;
				minDpT = dpT;
			}
		}
		
		jetCorrUnc->setJetEta(x.eta());	
		jetCorrUnc->setJetPt(x.pt());	
		const double unc = jetCorrUnc->getUncertainty(true);
		
		LogDebug("jets") << "n__jet=" << n__jet << CANDPRINT(x) << " puid=" << x.userFloat("pileupJetId:fullDiscriminant") << " unc=" << unc;

		tthtree->jet__eta			[n__jet] = x.eta();
		tthtree->jet__pt			[n__jet] = x.pt();
		tthtree->jet__pt_alt		[n__jet] = x.correctedJet("Uncorrected").pt();
		tthtree->jet__phi			[n__jet] = x.phi();
		tthtree->jet__mass			[n__jet] = x.mass();
		tthtree->jet__energy		[n__jet] = x.energy();
		tthtree->jet__bd_csv		[n__jet] = x.bDiscriminator("combinedSecondaryVertexBJetTags");
		tthtree->jet__id			[n__jet] = x.partonFlavour();
		tthtree->jet__unc			[n__jet] = unc;

		tthtree->jet__jetId			[n__jet] = int(jetID( x ));
		tthtree->jet__pileupJetId	[n__jet] = x.userFloat("pileupJetId:fullDiscriminant");
		tthtree->jet__pass_pileupJetId	[n__jet] = pu_mva::pass_id(x, x.userFloat("pileupJetId:fullDiscriminant"));
		tthtree->jet__vtxMass		[n__jet] = x.userFloat("vtxMass") ;
		tthtree->jet__vtxNtracks	[n__jet] = x.userFloat("vtxNtracks");
		tthtree->jet__vtx3DVal		[n__jet] = x.userFloat("vtx3DVal");
		tthtree->jet__vtx3DSig		[n__jet] = x.userFloat("vtx3DSig");

		tthtree->jet__nh_e			[n__jet] = x.neutralHadronEnergy();
		tthtree->jet__ne_e			[n__jet] = x.neutralEmEnergy();
		tthtree->jet__ch_e			[n__jet] = x.chargedHadronEnergy();
		tthtree->jet__ce_e			[n__jet] = x.chargedEmEnergy();
		tthtree->jet__mu_e			[n__jet] = x.muonEnergy();
		tthtree->jet__el_e			[n__jet] = x.electronEnergy();
		tthtree->jet__ph_e			[n__jet] = x.photonEnergy();

		//unsigned int constituent_idx = 0;
		//for (const auto& constituent : x.getJetConstituents()) {
		//	if (n__jet >= M_MAX || constituent_idx >= M_MAX) {
		//		LogDebug("jet") << "jet constituent maximum count reached: n__jet=" << n__jet << " n_constituent=" << constituent_idx << " max=" << M_MAX;
		//		break;
		//	}
		//	if (constituent.isNull()) {
		//		edm::LogWarning("jet") << "jet constituent is null: n__jet=" << n__jet << " n_constituent=" << constituent_idx;
		//		break;
		//	}
		//	tthtree->jet__c_pt[n__jet][constituent_idx] = constituent->pt();
		//	constituent_idx += 1;
		//}

		if (isMC_) {
			//generated parton
			const reco::GenParticle* gp = x.genParticle();
			if (gp == NULL) {
				LogDebug("jets") << "n__jet=" << n__jet << " does not have genParticle(), doing dR/dP matching";
				std::vector<const reco::GenParticle*> matched;
				for (auto& p : *pruned) {
					const float dr = sqrt(reco::deltaR2(x.p4(), p.p4()));
					const float rel_dp = fabs(x.pt()-p.pt())/p.pt();
					//LogDebug("jets") << "dR=" << dr << " rel_dp=" << rel_dp;
					if (dr<GENJET_DR && rel_dp<GENJET_REL_DP) {
						matched.push_back(&p);
					}
				}
				LogDebug("jets") << "dR < " << GENJET_DR << " matched " << matched.size();

				//sort genparticles by dR(recojet, genparticle) ascending
				auto sortf = [&x](const reco::GenParticle* a, const reco::GenParticle* b) -> bool {
					return (reco::deltaR2(x.p4(), a->p4()) < reco::deltaR2(x.p4(), b->p4()));
				};

				std::sort(matched.begin(), matched.end(), sortf);
				//if we had at least one match, choose lowest dR
				if (matched.size()>0) {
					gp = matched[0];
					LogDebug("jets") << "best match " << PCANDPRINT(gp);
				}
			}

			if (gp != NULL) {
				tthtree->gen_jet_parton__eta[n__jet] = gp->eta();
				tthtree->gen_jet_parton__pt[n__jet] = gp->pt();
				tthtree->gen_jet_parton__phi[n__jet] = gp->phi();
				tthtree->gen_jet_parton__mass[n__jet] = gp->mass();
				tthtree->gen_jet_parton__id[n__jet] = gp->pdgId();
				tthtree->gen_jet_parton__status[n__jet] = gp->status();

				//we can also loop over the gen particle mothers
				for (auto _m : gp->motherRefVector()) {
					if (_m.isNull()) {
						continue;
					}
					auto& m = *_m;
					LogDebug("jets") << "jet " << n__jet << " genParticle mother " << CANDPRINT(m);
				}
			} else {
				LogDebug("jets") << "jet " << n__jet << " genParticle==0";
			}

			//generator-level jet
			const reco::GenJet* gj = x.genJet();
			if (gj != NULL) {
				tthtree->gen_jet__eta[n__jet] = gj->eta();
				tthtree->gen_jet__pt[n__jet] = gj->pt();
				tthtree->gen_jet__phi[n__jet] = gj->phi();
				tthtree->gen_jet__mass[n__jet] = gj->mass();

				//FIXME: this id assignment does not seem to be correct. See issue #5 https://github.com/jpata/tthbb13/issues/5
				//tthtree->gen_jet__id[n__jet] = gj->pdgId();

				tthtree->gen_jet__status[n__jet] = gj->status();

				////Get generator level constituents
				////FIXME: do we want to save the constituents or just perform some maths on it?
				//unsigned int i = 0;
				//for (auto cn : gj->getGenConstituents()) {
				//	if (i >= M_MAX || n__jet >= M_MAX) {
				//		LogDebug("jets") << "constituent " << i << " loop iteration exceeded M_MAX=" << M_MAX;
				//		break;
				//	}
				//	if (cn != NULL) {
				//		LogDebug("jets") << "constituent " << i << " is null";
				//		continue;
				//	} else {
				//		LogDebug("jets") << "constituent " << i << " is not null";
				//	}
				//	LogDebug("jets") << "constituent " << i << cn->pt();
				//	LogDebug("jets") << "constituent " << i << " " << PCANDPRINT(cn);
				//	LogDebug("jets") << "constituent " << i << " end of loop";
				//	i += 1;
				//}


			} else {
				LogDebug("jet") << "jet " << n__jet << " did not have genJet";
			}
		} // isMC
		n__jet += 1;

		analysis_jets.push_back(x);
	} //jet loop

	//loop over all gen jets and find number of true B/C jets
	if (isMC_) {
		int n_sim_b = 0;
		int n_sim_c = 0;

		//NB: this reco::GenJet::pdgId() does not contain useful information. Need a more sophisticated formula
		//edm::Handle<std::vector<reco::GenJet>> genjets;
		//iEvent.getByToken(genJetToken_, genjets);
		//for (auto& p : *genjets) {
		//	cout << "genjet " << p.pdgId();
		//	if(TMath::Abs((int)p.pdgId()) == 5) {
		//		n_sim_b += 1;	
		//	}
		//	else if(TMath::Abs((int)p.pdgId()) == 4) {
		//		n_sim_c += 1;	
		//	}
		//}

		tthtree->n_sim_b = n_sim_b;
		tthtree->n_sim_c = n_sim_c;
		LogDebug("nsim") << n_sim_b << " " << n_sim_c;
	}

	LogDebug("content") << analysis_electrons.size() << " " << analysis_muons.size() << " " << analysis_taus.size() << " " << analysis_jets.size();
       
	//do initial hypothesis assignment
	//identify signal leptons under two hypotheses: single lepton (tight), dilepton (loose)
	vector<const pat::Muon*> good_muons_sl = TTH::find_good_muons(analysis_muons, PV, TTH::DecayMode::semileptonic);
	vector<const pat::Electron*> good_electrons_sl = TTH::find_good_electrons(analysis_electrons, PV, TTH::DecayMode::semileptonic);
	vector<const pat::Tau*> good_taus_sl = TTH::find_good_taus(analysis_taus, TTH::DecayMode::semileptonic);
	vector<const pat::Jet*> good_jets_sl = TTH::find_good_jets(analysis_jets, TTH::DecayMode::semileptonic);
	
	vector<const pat::Muon*> good_muons_dl = TTH::find_good_muons(analysis_muons, PV, TTH::DecayMode::dileptonic);
	vector<const pat::Electron*> good_electrons_dl = TTH::find_good_electrons(analysis_electrons, PV, TTH::DecayMode::dileptonic);
	vector<const pat::Tau*> good_taus_dl = TTH::find_good_taus(analysis_taus, TTH::DecayMode::dileptonic);
	vector<const pat::Jet*> good_jets_dl = TTH::find_good_jets(analysis_jets, TTH::DecayMode::dileptonic);

	//Identify veto leptons, which are guaranteed not to overlap with signal leptons
	vector<const pat::Muon*> veto_muons_sl = TTH::find_veto_muons(analysis_muons, good_muons_sl, TTH::DecayMode::semileptonic);
	vector<const pat::Electron*> veto_electrons_sl = TTH::find_veto_electrons(analysis_electrons, good_electrons_sl, TTH::DecayMode::semileptonic);
	vector<const pat::Tau*> veto_taus_sl = TTH::find_veto_taus(analysis_taus, good_taus_sl, TTH::DecayMode::semileptonic);
	
	vector<const pat::Muon*> veto_muons_dl = TTH::find_veto_muons(analysis_muons, good_muons_dl, TTH::DecayMode::dileptonic);
	vector<const pat::Electron*> veto_electrons_dl = TTH::find_veto_electrons(analysis_electrons, good_electrons_dl, TTH::DecayMode::dileptonic);
	vector<const pat::Tau*> veto_taus_dl = TTH::find_veto_taus(analysis_taus, good_taus_dl, TTH::DecayMode::dileptonic);

	//Build two event descriptions according to the hypotheses
	TTH::EventDescription desc_sl(
		good_muons_sl, good_electrons_sl, good_taus_sl,
		veto_muons_sl, veto_electrons_sl, veto_taus_sl,
		good_jets_sl
	);
	TTH::EventDescription desc_dl(
		good_muons_dl, good_electrons_dl, good_taus_dl,
		veto_muons_dl, veto_electrons_dl, veto_taus_dl,
		good_jets_dl
	);

	LogDebug("hypo") << "SL hypo mu " << good_muons_sl.size() << " ele " << good_electrons_sl.size() << " tau " << good_taus_sl.size() << " jet " << good_jets_sl.size();
	LogDebug("hypo") << "DL hypo mu " << good_muons_dl.size() << " ele " << good_electrons_dl.size() << " tau " << good_taus_dl.size() << " jet " << good_jets_sl.size();
	
	TTH::EventHypothesis hypo = assign_event_hypothesis(desc_sl, desc_dl);
	LogDebug("hypo") << "chosen hypo " << hypo;
	tthtree->hypo1 = (int)hypo;

	//Dilepton hypothesis, concatenate lepton arrays, sort by pt and put into TTree array
	vector<const reco::Candidate*> good_leptons;
	if (hypo == TTH::EventHypothesis::ee ||
		hypo == TTH::EventHypothesis::mumu ||
		hypo == TTH::EventHypothesis::tautau ||
		hypo == TTH::EventHypothesis::emu ||
		hypo == TTH::EventHypothesis::taue ||
		hypo == TTH::EventHypothesis::taumu
	) {
		for (auto* x : good_muons_dl) {
			good_leptons.push_back((const reco::Candidate*)x); 
		}
		for (auto* x : good_electrons_dl) {
			good_leptons.push_back((const reco::Candidate*)x); 
		}
		for (auto* x : good_taus_dl) {
			good_leptons.push_back((const reco::Candidate*)x); 
		}

		//must be 2, otherwise there was a bug in the hypothesis assignment
		assert(good_leptons.size()==2);
	}
	
	if (hypo == TTH::EventHypothesis::en ||
		hypo == TTH::EventHypothesis::mun ||
		hypo == TTH::EventHypothesis::taun
	) {
		for (auto* x : good_muons_sl) {
			good_leptons.push_back((const reco::Candidate*)x); 
		}
		for (auto* x : good_electrons_sl) {
			good_leptons.push_back((const reco::Candidate*)x); 
		}
		for (auto* x : good_taus_sl) {
			good_leptons.push_back((const reco::Candidate*)x); 
		}

		//must be 1, otherwise there was a bug in the hypothesis assignment
		assert(good_leptons.size()==1);
	
	}
	//sort by pt descending
	sort(good_leptons.begin(), good_leptons.end(), order_by_pt<const reco::Candidate*>);
	
	if (!is_unique_hypothesis(desc_sl, desc_dl)) {
		edm::LogWarning("hypo") << "ununique hypo detected"; 
		cout << "SL ";
		desc_sl.print(); 
		cout << "DL ";
		desc_dl.print();
		tthtree->hypo1 = TTH::EventHypothesis::BAD_HYPO;
	}

	for (unsigned int i=0; i<good_leptons.size(); i++) {
		tthtree->sig_lep__pt[i] = good_leptons[i]->pt();
		tthtree->sig_lep__eta[i] = good_leptons[i]->eta();
		tthtree->sig_lep__phi[i] = good_leptons[i]->phi();
		tthtree->sig_lep__mass[i] = good_leptons[i]->mass();
		tthtree->sig_lep__id[i] = good_leptons[i]->pdgId();
		tthtree->sig_lep__type[i] = abs(good_leptons[i]->pdgId());
		tthtree->sig_lep__charge[i] = good_leptons[i]->charge();
		//get index into main lepton array
		auto lepidx = find(leptons.begin(), leptons.end(), good_leptons[i]);
		if (lepidx != leptons.end()) {
			tthtree->sig_lep__idx[i] = lepidx - leptons.begin();
			LogDebug("siglep") << good_leptons[i]->pt() << " " << tthtree->sig_lep__idx[i] << " " << tthtree->lep__pt[tthtree->sig_lep__idx[i]];
		} else {
			std::ostringstream ss;
			for (auto l : leptons)
				ss << l << " ";
			edm::LogWarning("siglep") << "Could not find lepton " << good_leptons[i] << " in collection";
		}
	}
	tthtree->n__sig_lep = good_leptons.size();

	if( jetMult_min_ > 0 && n__jet < jetMult_min_ ) {
		LogDebug("Event Cuts") << n__jet << " jets: skip this event" << endl;
		return;
	}
	
	
	// These quantities will be filled by gen_association
	// Last Tops in Chain
	vector<const reco::GenParticle*> tops_last;
	vector<const reco::GenParticle*> antitops_last;
	// First Tops in Chain
	vector<const reco::Candidate*> tops_first;
	vector<const reco::Candidate*> antitops_first;
	vector<const reco::GenParticle*> bquarks;
	vector<const reco::GenParticle*> antibquarks;
	
	// Hard partons (usually for QCD matching)
	vector<const reco::Candidate*> hard_partons;

	// Higgs Bosons
	double min_higgs_pt = 0.; 
	vector<const reco::Candidate*> gen_higgs;

	if (isMC_) {
	  gen_association(pruned, 
			  tthtree,
			  tops_last,
			  antitops_last,
			  tops_first,
			  antitops_first,
			  bquarks,
			  antibquarks);	  

	  if (ADD_TRUE_PARTON_MATCHING_FOR_FJ || ADD_TRUE_PARTON_MATCHING_FOR_HTT || ADD_TRUE_PARTON_MATCHING_FOR_CMSTT)
	    get_hard_partons(pruned, genPartonPt_min_, genPartonStatus_, hard_partons);

	  if (ADD_TRUE_HIGGS_MATCHING_FOR_FJ || ADD_TRUE_HIGGS_MATCHING_FOR_HTT || ADD_TRUE_HIGGS_MATCHING_FOR_CMSTT)
	    get_gen_higgs(pruned, min_higgs_pt, gen_higgs);

	}	

	// Combine tops and antitops for truth matching
	vector<const reco::Candidate*> tops_antitops_last; // empty list
	tops_antitops_last.insert(tops_antitops_last.end(), tops_last.begin(), tops_last.end()); // add tops
	tops_antitops_last.insert(tops_antitops_last.end(), antitops_last.begin(), antitops_last.end()); // add antis

	// Hadronically decaying top quarks - only take the ones passing the pT threshold
	float min_true_top_pt = 200;
	vector<const reco::Candidate*> hadronic_ts;
	for (vector<const reco::Candidate*>::const_iterator iter = tops_antitops_last.begin();
	     iter != tops_antitops_last.end();
	     ++iter){	  	  
	  if ( (is_hadronic_top(*iter) == 1) &&   // Check hadronic decay
	       ((*iter)->pt() > min_true_top_pt)) // Check pT
	    hadronic_ts.push_back(*iter);
	}

	// Sort the truth top/higgs/parton collections by pT descending 
	sort(hard_partons.begin(), hard_partons.end(), order_by_pt<const reco::Candidate*>);
	sort(gen_higgs.begin(),    gen_higgs.end(),    order_by_pt<const reco::Candidate*>);
	sort(hadronic_ts.begin(),  hadronic_ts.end(),  order_by_pt<const reco::Candidate*>);

	// Fill the genparticle branches
	fill_genparticle_branches(tthtree, hard_partons, "parton");
	fill_genparticle_branches(tthtree, gen_higgs,    "higgs");
	fill_genparticle_branches(tthtree, hadronic_ts,  "hadtop");
  
      
	// Loop over HTT collections
	for (unsigned i_htt_coll = 0; i_htt_coll < htt_objects_.size(); i_htt_coll++){

	  // Get the proper names
	  std::string htt_object_name   = htt_objects_[i_htt_coll];
	  std::string htt_branches_name = htt_branches_[i_htt_coll];
 	  
	  // Top tagger jets
	  edm::Handle<edm::View<reco::BasicJet>> top_jets;
	  iEvent.getByLabel(htt_object_name, top_jets);

	  // Extra Info
	  edm::Handle<edm::View<reco::HTTTopJetTagInfo>> top_jet_infos;
	  iEvent.getByLabel(htt_object_name, top_jet_infos);

	  // Make sure both collections have the same size
	  assert(top_jets->size()==top_jet_infos->size());

          // HEPTopTagger
	  // Top jets and subjets are associated by indices. See:
	  // /cvmfs/cms.cern.ch/slc6_amd64_gcc481/cms/cmssw/CMSSW_7_0_9/src/RecoJets/JetProducers/plugins/CompoundJetProducer.cc
	  // about the association
	  int n_top_jet_subjet = 0;

	  // Loop over top candidates
	  for (unsigned int n_top_jet=0; n_top_jet<top_jets->size(); n_top_jet++) {

	    const reco::BasicJet& x = top_jets->at(n_top_jet);
	    const reco::HTTTopJetTagInfo& jet_info = top_jet_infos->at(n_top_jet);

	    LogDebug("top jets") << "n_top_jet=" << n_top_jet << CANDPRINT(x);

	    std::string prefix("jet_");
	    prefix.append(htt_branches_name);
	    prefix.append("__");

	    tthtree->get_address<float *>(prefix + "eta"    )[n_top_jet] = x.eta();
	    tthtree->get_address<float *>(prefix + "pt"     )[n_top_jet] = x.pt();
	    tthtree->get_address<float *>(prefix + "phi"    )[n_top_jet] = x.phi();
	    tthtree->get_address<float *>(prefix + "mass"   )[n_top_jet] = x.mass();

	    tthtree->get_address<float *>(prefix + "fj_pt"   )[n_top_jet] = jet_info.properties().fjPt;
	    tthtree->get_address<float *>(prefix + "fj_mass" )[n_top_jet] = jet_info.properties().fjMass;
	    tthtree->get_address<float *>(prefix + "fj_eta"  )[n_top_jet] = jet_info.properties().fjEta;
	    tthtree->get_address<float *>(prefix + "fj_phi"  )[n_top_jet] = jet_info.properties().fjPhi;

	    tthtree->get_address<float *>(prefix + "topMass" )[n_top_jet] = jet_info.properties().topMass;

	    tthtree->get_address<float *>(prefix + "unfilteredMass" )[n_top_jet] = jet_info.properties().unfilteredMass;
	    tthtree->get_address<float *>(prefix + "prunedMass" )[n_top_jet]	 = jet_info.properties().prunedMass;
	    tthtree->get_address<float *>(prefix + "fRec" )[n_top_jet]		 = jet_info.properties().fRec;

	    tthtree->get_address<float *>(prefix + "massRatioPassed" )[n_top_jet]  = jet_info.properties().massRatioPassed;

	    tthtree->get_address<float *>(prefix + "Ropt" )[n_top_jet]		= jet_info.properties().Ropt;
	    tthtree->get_address<float *>(prefix + "RoptCalc" )[n_top_jet]	= jet_info.properties().RoptCalc;
	    tthtree->get_address<float *>(prefix + "ptForRoptCalc" )[n_top_jet] = jet_info.properties().ptForRoptCalc;

	    tthtree->get_address<float *>(prefix + "tau1unfilt" )[n_top_jet]	= jet_info.properties().tau1Unfiltered;
	    tthtree->get_address<float *>(prefix + "tau2unfilt" )[n_top_jet]	= jet_info.properties().tau2Unfiltered;
	    tthtree->get_address<float *>(prefix + "tau3unfilt" )[n_top_jet]	= jet_info.properties().tau3Unfiltered;

	    tthtree->get_address<float *>(prefix + "tau1filt" )[n_top_jet]	= jet_info.properties().tau1Filtered;
	    tthtree->get_address<float *>(prefix + "tau2filt" )[n_top_jet]	= jet_info.properties().tau2Filtered;
	    tthtree->get_address<float *>(prefix + "tau3filt" )[n_top_jet]	= jet_info.properties().tau3Filtered;

	    tthtree->get_address<float *>(prefix + "qweight" )[n_top_jet]	= jet_info.properties().QWeight;
	    tthtree->get_address<float *>(prefix + "qepsilon")[n_top_jet]	= jet_info.properties().QEpsilon;
	    tthtree->get_address<float *>(prefix + "qsigmam" )[n_top_jet]	= jet_info.properties().QSigmaM;

	    tthtree->get_address<int *>(prefix + "n_sj" )[n_top_jet]  = 3;
	   
	    // Optional: Fill truth matching information
	    if (ADD_TRUE_TOP_MATCHING_FOR_HTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hadronic_ts, prefix, "hadtop");
	    if (ADD_TRUE_PARTON_MATCHING_FOR_HTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hard_partons, prefix, "parton");
	    if (ADD_TRUE_HIGGS_MATCHING_FOR_HTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, gen_higgs, prefix, "higgs");
	    
	    bool first = true;
	    for (auto& constituent : x.getJetConstituents()) {
	      if (constituent.isNull()) {
		edm::LogWarning("top jets") << "n_top_jet=" << n_top_jet << " constituent is not valid";
		break;
	      }
	      if (first) {
	      	tthtree->get_address<int *>(prefix + "child_idx" )[n_top_jet]  = n_top_jet_subjet;
	      }
	      
	      std::string prefix_sj("jet_");
	      prefix_sj.append(htt_branches_name);
	      prefix_sj.append("_sj__");

	      tthtree->get_address<float *>(prefix_sj + "pt" )[n_top_jet_subjet]  = constituent->pt();
	      tthtree->get_address<float *>(prefix_sj + "eta" )[n_top_jet_subjet]  = constituent->eta();
	      tthtree->get_address<float *>(prefix_sj + "phi" )[n_top_jet_subjet]  = constituent->phi();
	      tthtree->get_address<float *>(prefix_sj + "mass" )[n_top_jet_subjet]  = constituent->mass();
	      tthtree->get_address<float *>(prefix_sj + "energy" )[n_top_jet_subjet]  = constituent->energy();

	      tthtree->get_address<int *>(prefix_sj + "parent_idx" )[n_top_jet_subjet]  = n_top_jet;

	      n_top_jet_subjet += 1;	      
	      first = false;
	    }
	  } // End of loop over candidates

	  // Also fill counters	  
	  std::string ncand_branch("n__jet_");
	  ncand_branch.append(htt_branches_name);

	  std::string ncand_sj_branch("n__jet_");
	  ncand_sj_branch.append(htt_branches_name);
	  ncand_sj_branch.append("_sj");
	  
	  *(tthtree->get_address<int *>(ncand_branch ))    = top_jets->size();
	  *(tthtree->get_address<int *>(ncand_sj_branch )) = n_top_jet_subjet;

	} // End of filling HTT related branches

	
	// Loop over CMSTT collections
	for (unsigned i_cmstt_coll = 0; i_cmstt_coll < cmstt_objects_.size(); i_cmstt_coll++){

	  // Get the proper names
	  std::string cmstt_object_name   = cmstt_objects_[i_cmstt_coll];
	  std::string cmstt_infos_name    = cmstt_infos_[i_cmstt_coll];
	  std::string cmstt_branches_name = cmstt_branches_[i_cmstt_coll];
	  std::string cmstt_btags_name     = cmstt_btags_[i_cmstt_coll];
 	  
	  // Top tagger jets
	  edm::Handle<edm::View<reco::BasicJet>> top_jets;
	  iEvent.getByLabel(cmstt_object_name, top_jets);

	  // Extra Info
	  edm::Handle<edm::View<reco::CATopJetTagInfo>> top_jet_infos;
	  iEvent.getByLabel(cmstt_infos_name, top_jet_infos);
	  	  
	  // Make sure both collections have the same size
	  assert(top_jets->size()==top_jet_infos->size());

	  // b-tag discriminators handle
	  edm::Handle<reco::JetTagCollection> btagDiscriminators;
	  if (cmstt_btags_name != "None")
	    iEvent.getByLabel(cmstt_btags_name, btagDiscriminators);


	  // Top jets and subjets are associated by indices. See:
	  // /cvmfs/cms.cern.ch/slc6_amd64_gcc481/cms/cmssw/CMSSW_7_0_9/src/RecoJets/JetProducers/plugins/CompoundJetProducer.cc
	  // about the association
	  int n_top_jet_subjet = 0;

	  // Loop over top candidates
	  for (unsigned int n_top_jet=0; n_top_jet<top_jets->size(); n_top_jet++) {

	    const reco::BasicJet& x = top_jets->at(n_top_jet);
	    const reco::CATopJetTagInfo& jet_info = top_jet_infos->at(n_top_jet);

	    std::string prefix("jet_");
	    prefix.append(cmstt_branches_name);
	    prefix.append("__");

	    tthtree->get_address<float *>(prefix + "eta"    )[n_top_jet] = x.eta();
	    tthtree->get_address<float *>(prefix + "pt"     )[n_top_jet] = x.pt();
	    tthtree->get_address<float *>(prefix + "phi"    )[n_top_jet] = x.phi();
	    tthtree->get_address<float *>(prefix + "mass"   )[n_top_jet] = x.mass();

	    tthtree->get_address<float *>(prefix + "minMass" )[n_top_jet] = jet_info.properties().minMass;
	    tthtree->get_address<float *>(prefix + "wMass" )[n_top_jet] = jet_info.properties().wMass;
	    tthtree->get_address<float *>(prefix + "topMass" )[n_top_jet] = jet_info.properties().topMass;
	    tthtree->get_address<int   *>(prefix + "nSubJets" )[n_top_jet] = jet_info.properties().nSubJets;
	   	    
	    // Optional: Fill truth matching information
	    if (ADD_TRUE_TOP_MATCHING_FOR_CMSTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hadronic_ts, prefix, "hadtop");
	    if (ADD_TRUE_PARTON_MATCHING_FOR_CMSTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, hard_partons, prefix, "parton");
	    if (ADD_TRUE_HIGGS_MATCHING_FOR_CMSTT)
	      fill_truth_matching<reco::BasicJet>(tthtree, x, n_top_jet, gen_higgs, prefix, "higgs");
	    
	    bool first = true;
	    for (auto& constituent : x.getJetConstituents()) {
	      if (constituent.isNull()) {
		edm::LogWarning("top jets") << "n_top_jet=" << n_top_jet << " constituent is not valid";
		break;
	      }
	      if (first) {
	      	tthtree->get_address<int *>(prefix + "child_idx" )[n_top_jet]  = n_top_jet_subjet;
	      }
	      
	      std::string prefix_sj("jet_");
	      prefix_sj.append(cmstt_branches_name);
	      prefix_sj.append("_sj__");

	      tthtree->get_address<float *>(prefix_sj + "pt" )[n_top_jet_subjet]  = constituent->pt();
	      tthtree->get_address<float *>(prefix_sj + "eta" )[n_top_jet_subjet]  = constituent->eta();
	      tthtree->get_address<float *>(prefix_sj + "phi" )[n_top_jet_subjet]  = constituent->phi();
	      tthtree->get_address<float *>(prefix_sj + "mass" )[n_top_jet_subjet]  = constituent->mass();
	      tthtree->get_address<float *>(prefix_sj + "energy" )[n_top_jet_subjet]  = constituent->energy();

	      // B-tag
	      if (cmstt_btags_name != "None"){
		tthtree->get_address<float *>(prefix_sj + "btag")[n_top_jet_subjet] = (*btagDiscriminators)[n_top_jet_subjet].second;
	      }

	      tthtree->get_address<int *>(prefix_sj + "parent_idx" )[n_top_jet_subjet]  = n_top_jet;

	      n_top_jet_subjet += 1;	      
	      first = false;
	    }
	  } // End of loop over candidates

	  // Also fill counters	  
	  std::string ncand_branch("n__jet_");
	  ncand_branch.append(cmstt_branches_name);

	  std::string ncand_sj_branch("n__jet_");
	  ncand_sj_branch.append(cmstt_branches_name);
	  ncand_sj_branch.append("_sj");
	  
	  *(tthtree->get_address<int *>(ncand_branch ))    = top_jets->size();
	  *(tthtree->get_address<int *>(ncand_sj_branch )) = n_top_jet_subjet;

	} // End of filling CMSTT related branches


	if (n__lep>=N_MAX) {
		edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__lep: " << n__lep << ">=> " << N_MAX;
		throw std::exception();
	}

	if (n__jet>=N_MAX) {
		edm::LogError("N_MAX") << "Exceeded vector N_MAX with n__jet: " << n__jet << ">=> " << N_MAX;
		throw std::exception();
	}

	// Loop over fatjet collections
	for (unsigned i_fj_coll = 0; i_fj_coll < fatjet_objects_.size(); i_fj_coll++){

	  // Get the proper names
	  std::string fj_object_name	  = fatjet_objects_[i_fj_coll];
	  std::string fj_nsubs_name	  = fatjet_nsubs_[i_fj_coll];
	  std::string fj_sds_name	  = fatjet_sds_[i_fj_coll];
	  std::string fj_btags_name	  = fatjet_btags_[i_fj_coll];
	  std::string fj_qvols_name	  = fatjet_qvols_[i_fj_coll];
	  std::string fj_branches_name    = fatjet_branches_[i_fj_coll];
	  int fj_usesubjets              = fatjet_usesubjets_[i_fj_coll];
	  

	  fill_fatjet_branches<reco::PFJet, reco::PFJetCollection>(iEvent, 
								   tthtree, 
								   fj_object_name,
								   fj_nsubs_name,
								   fj_sds_name,
								   fj_btags_name,
								   fj_qvols_name,
								   fj_branches_name,
								   hadronic_ts,
								   hard_partons,
								   gen_higgs,
								   fj_usesubjets
								   );
	 
	} // End of loop over fatjet collections
	// Done filling the fatjet information


	edm::Handle<pat::METCollection> mets;
	iEvent.getByToken(metToken_, mets);
	const pat::MET &met = mets->front();
	tthtree->met__pt = met.pt();
	tthtree->met__phi = met.phi();
	
	tthtree->met__sumet = met.sumEt();

	//do MET shifting
	if (isMC_) {

		tthtree->n__met_shift = 12;

		// Pt
		tthtree->met__pt__shift[0]	= met.shiftedPt(pat::MET::JetEnUp);
		tthtree->met__pt__shift[1]	= met.shiftedPt(pat::MET::JetEnDown);
		tthtree->met__pt__shift[2]	= met.shiftedPt(pat::MET::JetResUp);
		tthtree->met__pt__shift[3]	= met.shiftedPt(pat::MET::JetResDown);
		tthtree->met__pt__shift[4]	= met.shiftedPt(pat::MET::MuonEnUp);
		tthtree->met__pt__shift[5]	= met.shiftedPt(pat::MET::MuonEnDown);
		tthtree->met__pt__shift[6]	= met.shiftedPt(pat::MET::ElectronEnUp);
		tthtree->met__pt__shift[7]	= met.shiftedPt(pat::MET::ElectronEnDown);
		tthtree->met__pt__shift[8]	= met.shiftedPt(pat::MET::TauEnUp);
		tthtree->met__pt__shift[9]	= met.shiftedPt(pat::MET::TauEnDown);
		tthtree->met__pt__shift[10]	= met.shiftedPt(pat::MET::UnclusteredEnUp);
		tthtree->met__pt__shift[11]	= met.shiftedPt(pat::MET::UnclusteredEnDown);

		// Px
		tthtree->met__px__shift[0]	= met.shiftedPx(pat::MET::JetEnUp);
		tthtree->met__px__shift[1]	= met.shiftedPx(pat::MET::JetEnDown);
		tthtree->met__px__shift[2]	= met.shiftedPx(pat::MET::JetResUp);
		tthtree->met__px__shift[3]	= met.shiftedPx(pat::MET::JetResDown);
		tthtree->met__px__shift[4]	= met.shiftedPx(pat::MET::MuonEnUp);
		tthtree->met__px__shift[5]	= met.shiftedPx(pat::MET::MuonEnDown);
		tthtree->met__px__shift[6]	= met.shiftedPx(pat::MET::ElectronEnUp);
		tthtree->met__px__shift[7]	= met.shiftedPx(pat::MET::ElectronEnDown);
		tthtree->met__px__shift[8]	= met.shiftedPx(pat::MET::TauEnUp);
		tthtree->met__px__shift[9]	= met.shiftedPx(pat::MET::TauEnDown);
		tthtree->met__px__shift[10]	= met.shiftedPx(pat::MET::UnclusteredEnUp);
		tthtree->met__px__shift[11]	= met.shiftedPx(pat::MET::UnclusteredEnDown);

		// Py
		tthtree->met__py__shift[0]		= met.shiftedPy(pat::MET::JetEnUp);
		tthtree->met__py__shift[1]		= met.shiftedPy(pat::MET::JetEnDown);
		tthtree->met__py__shift[2]		= met.shiftedPy(pat::MET::JetResUp);
		tthtree->met__py__shift[3]		= met.shiftedPy(pat::MET::JetResDown);
		tthtree->met__py__shift[4]		= met.shiftedPy(pat::MET::MuonEnUp);
		tthtree->met__py__shift[5]		= met.shiftedPy(pat::MET::MuonEnDown);
		tthtree->met__py__shift[6]		= met.shiftedPy(pat::MET::ElectronEnUp);
		tthtree->met__py__shift[7]		= met.shiftedPy(pat::MET::ElectronEnDown);
		tthtree->met__py__shift[8]		= met.shiftedPy(pat::MET::TauEnUp);
		tthtree->met__py__shift[9]		= met.shiftedPy(pat::MET::TauEnDown);
		tthtree->met__py__shift[10]		= met.shiftedPy(pat::MET::UnclusteredEnUp);
		tthtree->met__py__shift[11]		= met.shiftedPy(pat::MET::UnclusteredEnDown);

		// Phi
		tthtree->met__phi__shift[0]		= met.shiftedPhi(pat::MET::JetEnUp);
		tthtree->met__phi__shift[1]		= met.shiftedPhi(pat::MET::JetEnDown);
		tthtree->met__phi__shift[2]		= met.shiftedPhi(pat::MET::JetResUp);
		tthtree->met__phi__shift[3]		= met.shiftedPhi(pat::MET::JetResDown);
		tthtree->met__phi__shift[4]		= met.shiftedPhi(pat::MET::MuonEnUp);
		tthtree->met__phi__shift[5]		= met.shiftedPhi(pat::MET::MuonEnDown);
		tthtree->met__phi__shift[6]		= met.shiftedPhi(pat::MET::ElectronEnUp);
		tthtree->met__phi__shift[7]		= met.shiftedPhi(pat::MET::ElectronEnDown);
		tthtree->met__phi__shift[8]		= met.shiftedPhi(pat::MET::TauEnUp);
		tthtree->met__phi__shift[9]		= met.shiftedPhi(pat::MET::TauEnDown);
		tthtree->met__phi__shift[10]	= met.shiftedPhi(pat::MET::UnclusteredEnUp);
		tthtree->met__phi__shift[11]	= met.shiftedPhi(pat::MET::UnclusteredEnDown);

		tthtree->gen_met__pt = met.genMET()->pt();
		tthtree->gen_met__sumet = met.genMET()->sumEt();
		tthtree->gen_met__phi = met.genMET()->phi();
	} //isMC for shifted MET

	//get the LHE gen-level stuff
	//code from LB --> LHE not always available
	if ( isMC_ ) {
		edm::Handle<LHEEventProduct> lhe;
		if( !lheToken_.isUninitialized() )
			iEvent.getByToken(lheToken_, lhe);

		if( lhe.isValid() ) {

			const lhef::HEPEUP hepeup_ = lhe->hepeup();
			const std::vector<lhef::HEPEUP::FiveVector> pup_ = hepeup_.PUP; // px, py, pz, E, M

			double lheHT = 0.0;
			unsigned int lheNj = 0;
			unsigned int countBquarks=0, countCquarks=0, countUDSquarks=0, countGquarks=0, countExtraPartons=0;
			for (unsigned int i=0; i<pup_.size(); ++i) {
				int id=hepeup_.IDUP[i]; //pdgId
				int status = hepeup_.ISTUP[i];
				int idabs=TMath::Abs(id);

				// gluons and quarks
				if(status == 1 && ((idabs == 21) || (idabs > 0 && idabs < 7))) {
					// first entry is px, second py
					lheHT += TMath::Sqrt( TMath::Power(hepeup_.PUP[i][0],2) + TMath::Power(hepeup_.PUP[i][1],2) );
					lheNj++;
				}

				if ( hepeup_.ISTUP[i] >= 0 && status == 1 ) {
					if (!(hepeup_.MOTHUP[i].first !=1 && hepeup_.MOTHUP[i].second !=2)) {
						if(idabs==5 ) countBquarks++;
						if(idabs==4 ) countCquarks++;
						if(idabs<=3 && idabs>=1 ) countUDSquarks++;
						if(idabs==21 ) countGquarks++;
						if(idabs==21 || (idabs>=1 && idabs<=5)) countExtraPartons++;
					}
				}
			}
			tthtree->lhe__ht = lheHT;
			tthtree->lhe__n_j = lheNj;
			tthtree->lhe__n_b = countBquarks;
			tthtree->lhe__n_c = countCquarks;
			tthtree->lhe__n_l = countUDSquarks;
			tthtree->lhe__n_g = countGquarks;
			tthtree->lhe__n_e = countExtraPartons;
		}
	} // isMC for LHE

	//These also index the number of generated lepton/jets
	tthtree->n__lep = n__lep;
	tthtree->n__jet = n__jet;

	sw->Stop();
	tthtree->debug__time1r = sw->RealTime();
	tthtree->debug__time1c = sw->CpuTime();
	LogDebug("time") << "timing " << tthtree->debug__time1r << " " << tthtree->debug__time1c;
	tthtree->tree->Fill();
	
	//fill passed 
	hcounter->SetBinContent(2, hcounter->GetBinContent(2)+1);
}

// ------------ method called once each job just before starting event loop  ------------
void
TTHNtupleAnalyzer::beginJob()
{
}

// ------------ method called once each job just after ending the event loop  ------------
void
TTHNtupleAnalyzer::endJob()
{
}

// ------------ method called when starting to processes a run  ------------
/*
void
TTHNtupleAnalyzer::beginRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a run  ------------
/*
void
TTHNtupleAnalyzer::endRun(edm::Run const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when starting to processes a luminosity block  ------------
/*
void
TTHNtupleAnalyzer::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method called when ending the processing of a luminosity block  ------------
/*
void
TTHNtupleAnalyzer::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
TTHNtupleAnalyzer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
	//The following says we do not know what parameters are allowed so do no validation
	// Please change this to state exactly what you do use, even if it is no parameters
	edm::ParameterSetDescription desc;
	desc.setUnknown();
	descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(TTHNtupleAnalyzer);
